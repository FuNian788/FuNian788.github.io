<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://FuNian788.github.io</id>
    <title>Zexian Li</title>
    <updated>2021-05-11T02:47:45.391Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://FuNian788.github.io"/>
    <link rel="self" href="https://FuNian788.github.io/atom.xml"/>
    <subtitle>Colorful life.</subtitle>
    <logo>https://FuNian788.github.io/images/avatar.png</logo>
    <icon>https://FuNian788.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, Zexian Li</rights>
    <entry>
        <title type="html"><![CDATA[论文简读]]></title>
        <id>https://FuNian788.github.io/post/paper-easy-read/</id>
        <link href="https://FuNian788.github.io/post/paper-easy-read/">
        </link>
        <updated>2021-05-10T05:59:27.000Z</updated>
        <content type="html"><![CDATA[<p><ul class="markdownIt-TOC">
<li>
<ul>
<li>
<ul>
<li><a href="#1-mlp-mixer-an-all-mlp-architecture-for-vision">(1) MLP-Mixer: An all-MLP Architecture for Vision</a></li>
<li><a href="#2-acnet-strengthening-the-kernel-skeletons-for-powerful-cnn-via-asymmetric-convolution-blocks">(2) ACNet: Strengthening the Kernel Skeletons for Powerful CNN via Asymmetric Convolution Blocks</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</p>
<h3 id="1-mlp-mixer-an-all-mlp-architecture-for-vision">(1) <a href="https://arxiv.org/pdf/2105.01601.pdf">MLP-Mixer: An all-MLP Architecture for Vision</a></h3>
<p><strong>Make MLP great again</strong>🌝</p>
<p>MLP-Mixer包含两种MLP：token-mixing MLP每次处理单个通道，进行不同patch间的信息交换(图中一个patch使用一种颜色)；channel-mixing MLP每次处理单个patch，进行通道上的信息交换。<br>
如下图所示，每个Mixer Layer包含一个token-mixing MLP(MLP1)和channel-mixing MLP(MLP2)。具体地，每个MLP包含两个fc层和一个GELU层(<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>G</mi><mi>E</mi><mi>L</mi><mi>U</mi><mo>(</mo><mi>x</mi><mo>)</mo><mo>=</mo><mi>x</mi><mi>P</mi><mo>(</mo><mi>X</mi><mo>≤</mo><mi>x</mi><mo>)</mo><mo>=</mo><mi>x</mi><mi mathvariant="normal">Φ</mi><mo>(</mo><mi>x</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">GELU(x) = xP(X\le x) = x\Phi (x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">G</span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mord mathdefault">L</span><span class="mord mathdefault" style="margin-right:0.10903em;">U</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">x</span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">x</span><span class="mord">Φ</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span>)；token-mixing MLP共享参数，<br>
<img src="https://FuNian788.github.io/post-images/object_detection/mixer_1.png" alt="mixer结构" loading="lazy"><br>
Depthwise Separable Convolution将卷积分成depthwise convolution和pointwise convolution两步来实现，这很有那味。但Depthwise Separable Convolution对不同通道使用不同卷积核，而Mixer对所有通道均使用相同的卷积核。</p>
<p>伪代码如下所示：<br>
<img src="https://FuNian788.github.io/post-images/object_detection/mixer_2.png" alt="伪代码" loading="lazy"><br>
对于(N, H=224, W=224, C)的原图片，设patch大小为(s_height=16, s_width=16)，可得到h=14*w=14个patch。<br>
MlpMixer中，Line36相当于对(N, H, W, C)的原图片，挨个patch处理其特征，输出(N, h, w, c)的特征，Line37将其resize到(N, hw, c)。将该特征送到token-mixing MLP中时，将其reshape到(N, hw, c)后接两个通道数为c的fc，将该特征送到channel-mixing时，将其reshape到(N, c, hw)后接两个通道数为hw的fc。</p>
<h3 id="2-acnet-strengthening-the-kernel-skeletons-for-powerful-cnn-via-asymmetric-convolution-blocks">(2) <a href="https://arxiv.org/pdf/1908.03930.pdf">ACNet: Strengthening the Kernel Skeletons for Powerful CNN via Asymmetric Convolution Blocks</a></h3>
<p><strong>重参数化：轻微延长训练时间以在不涨参数量的情况下获得涨点。</strong><br>
举例，<br>
<img src="https://FuNian788.github.io/post-images/object_detection/ACNet_1.png" alt="重参数化" loading="lazy"></p>
<p>宏观上来看ACNet分为训练和推理阶段，训练阶段重点在于强化特征提取，实现效果提升。而测试阶段重点在于卷积核融合，不增强任何计算量。</p>
<p>训练阶段：因为[公式]卷积是大多数网络的基础组件，因此ACNet的实验都是针对[公式]卷积进行的。训练阶段就是将现有网络中的每一个[公式]卷积换成[公式]卷积+[公式]卷积+[公式]卷积共三个卷积层，最终将这三个卷积层的计算结果进行融合获得卷积层的输出。因为这个过程中引入的[公式]卷积和[公式]卷积是非对称的，所以将其命名为Asymmetric Convolution。<br>
推理阶段：如Figure1右图所示，这部分主要是对三个卷积核进行融合。这部分在实现过程中就是使用融合后的卷积核参数来初始化现有的网络，因此在推理阶段，网络结构和原始网络是完全一样的了，只不过网络参数采用了特征提取能力更强的参数即融合后的卷积核参数，因此在推理阶段不会增加计算量。<br>
总结一下就是ACNet在训练阶段强化了原始网络的特征提取能力，在推理阶段融合卷积核达到不增加计算量的目的。虽然训练时间增加了一些时间，但却换来了对推理无痛的精度提升，怎么看都是一笔非常划算的交易。下面的Table3展示出来，对于AlexNet提升了比较多，而对ResNet和DenseNet提升不到一个百分点，不过考虑到这个提升是白赚的也还是非常值得肯定的。</p>
<p>换取不涨参数的</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Transformer in CV]]></title>
        <id>https://FuNian788.github.io/post/transformer-in-cv/</id>
        <link href="https://FuNian788.github.io/post/transformer-in-cv/">
        </link>
        <updated>2021-05-07T09:25:59.000Z</updated>
        <content type="html"><![CDATA[<p><ul class="markdownIt-TOC">
<li>
<ul>
<li>
<ul>
<li><a href="#1-2017-nipsattention-is-all-you-need">(1) (2017 NIPS)Attention is all you need</a></li>
<li><a href="#2-fairdetr-end-to-end-object-detection-with-transformers">(2) (FAIR)DETR: End-to-End Object Detection with Transformers</a></li>
<li><a href="#3-2021-iclr-oraldeformable-detr-deformable-transformers-for-end-to-end-object-detection">(3) (2021 ICLR oral)Deformable DETR: Deformable Transformers for End-to-End Object Detection</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</p>
<h3 id="1-2017-nipsattention-is-all-you-need">(1) <a href="https://arxiv.org/abs/1706.03762">(2017 NIPS)Attention is all you need</a></h3>
<figure data-type="image" tabindex="1"><img src="https://FuNian788.github.io/post-images/object_detection/transformer_1.png" alt="transformer结构图" loading="lazy"></figure>
<h3 id="2-fairdetr-end-to-end-object-detection-with-transformers">(2) <a href="https://arxiv.org/abs/2005.12872">(FAIR)DETR: End-to-End Object Detection with Transformers</a></h3>
<ul>
<li>
<p>Motivation</p>
</li>
<li>
<p>主要贡献<br>
把目标检测任务视为一个直接的集合预测问题。<br>
简化了检测流程，移除了很多人为设计的模块eg NMS、基于先验知识的方法eg anchor生成。</p>
</li>
<li>
<p>overall</p>
</li>
<li>
<p>实现细节</p>
</li>
</ul>
<p>匈牙利算法：<br>
参考Pecco的一篇<a href="https://zhuanlan.zhihu.com/p/96229700">知乎博客</a>，可将匈牙利算法的核心代码展示如下：</p>
<pre><code class="language-C">int M, N;            //M, N分别表示左、右侧集合的元素数量
int Map[MAXM][MAXN]; //邻接矩阵存图
int p[MAXN];         //记录当前右侧元素所对应的左侧元素
bool vis[MAXN];      //记录右侧元素是否已被访问过
bool match(int i)
{
    for (int j = 1; j &lt;= N; ++j)
        if (Map[i][j] &amp;&amp; !vis[j]) //有边且未访问
        {
            vis[j] = true;                 //记录状态为访问过
            if (p[j] == 0 || match(p[j])) //如果暂无匹配，或者原来匹配的左侧元素可以找到新的匹配
            {
                p[j] = i;    //当前左侧元素成为当前右侧元素的新匹配
                return true; //返回匹配成功
            }
        }
    return false; //循环结束，仍未找到匹配，返回匹配失败
}
int Hungarian()
{
    int cnt = 0;
    for (int i = 1; i &lt;= M; ++i)
    {
        memset(vis, 0, sizeof(vis)); //重置vis数组
        if (match(i))
            cnt++;
    }
    return cnt;
}
</code></pre>
<ul>
<li>改进/Challenge/idea/Que</li>
</ul>
<h3 id="3-2021-iclr-oraldeformable-detr-deformable-transformers-for-end-to-end-object-detection">(3) <a href="https://arxiv.org/abs/2010.04159">(2021 ICLR oral)Deformable DETR: Deformable Transformers for End-to-End Object Detection</a></h3>
<ul>
<li>
<p>前导知识<br>
ICCV 2017 Deformable Convolutional Networks提出了Deformable conv，如下图所示，deformable conv为基本卷积时围绕中心规整排列的所有采样点均叠加一个位置offset，在移动后的位置进行信息采样，能有效捕获物体的关键信息。<br>
<img src="https://FuNian788.github.io/post-images/object_detection/deform_conv_1.png" alt="deformable conv" loading="lazy"><br>
多层下基本卷积和deformable conv的区别示意图：<br>
<img src="https://FuNian788.github.io/post-images/object_detection/deform_conv_2.png" alt="deformable conv示意图" loading="lazy"><br>
该方法很容易理解，但代码实现时需要考虑：<br>
Q1 如何将deformable conv变成单独的一个层？<br>
A1 不对卷积核进行迁移，而是重新整合feature map，再进行正常的卷积。<br>
Q2 如何有效实现反向传播？<br>
feature map整合时，由于存在像素级偏移操作，而偏移量可能为浮点数类型。</p>
</li>
<li>
<p>Motivation<br>
DETR训练收敛速度慢：注意力模块在初始化时，对feature map所有位置给了近乎相同的权重，收敛就会很慢；</p>
</li>
</ul>
<p>，在小物体检测效果不佳。前者是因为</p>
<p>DETR受Transformer Attention module的限制，其收敛速度较慢，特征的分辨率也受限。</p>
<p>文章是detr的改进，主要解决detr收敛慢的问题，此外由于有限的特征空间分辨率，在检测小物体方面的性能相对较低<br>
作者将原始detr的encoder部分换成deformable attention module，感觉这一点很重要，此外引入了多尺度的特征，来提升小物体的检出性能。</p>
<p>较慢的收敛速度和</p>
<ul>
<li>
<p>主要贡献</p>
</li>
<li>
<p>overall</p>
</li>
<li>
<p>实现细节</p>
</li>
<li>
<p>改进/Challenge/idea/Que</p>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[目标检测论文阅读]]></title>
        <id>https://FuNian788.github.io/post/detection/</id>
        <link href="https://FuNian788.github.io/post/detection/">
        </link>
        <updated>2021-04-26T03:23:13.000Z</updated>
        <content type="html"><![CDATA[<p><ul class="markdownIt-TOC">
<li>
<ul>
<li><a href="#%E6%96%B9%E6%B3%95%E7%BB%BC%E8%BF%B0">方法综述</a></li>
<li><a href="#%E8%AF%84%E4%BB%B7%E6%8C%87%E6%A0%87">评价指标</a></li>
<li><a href="#%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E9%9B%86">常用数据集</a></li>
<li><a href="#%E6%8C%87%E6%A0%87%E6%AF%94%E5%AF%B9">指标比对</a></li>
<li><a href="#%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0">论文笔记</a>
<ul>
<li><a href="#1-2021-cvpryolof-you-only-look-one-level-feature">(1) (2021 CVPR)YOLOF: You Only Look One-level Feature</a></li>
<li><a href="#2-fairretinanet-focal-loss-for-dense-object-detection">(2) (FAIR)RetinaNet: Focal Loss for Dense Object Detection</a></li>
<li><a href="#3-2019-iccvfcos-fully-convolutional-one-stage-object-detection">(3) (2019 ICCV)FCOS: Fully Convolutional One-Stage Object Detection</a></li>
<li><a href="#4-2020-cvpr-oralatss-bridging-the-gap-between-anchor-based-and-anchor-free-detection-via-adaptive-training-sample-selection">(4) (2020 CVPR oral)ATSS: Bridging the Gap Between Anchor-based and Anchor-free Detection via Adaptive Training Sample Selection</a></li>
<li><a href="#5-2019-cvprhr-net-deep-high-resolution-representation-learning-for-visual-recognition">(5) (2019 CVPR)HR-Net: Deep High-Resolution Representation Learning for Visual Recognition</a></li>
</ul>
</li>
<li><a href="#%E5%9F%BA%E7%A1%80%E6%A8%A1%E5%9E%8B">基础模型</a>
<ul>
<li><a href="#1-2017-cvprresnext-aggregated-residual-transformations-for-deep-neural-networks">(1) (2017 CVPR)ResNeXt: Aggregated Residual Transformations for Deep Neural Networks</a></li>
<li><a href="#n-2021-cvprpaper-name">(n) (2021 CVPR)PAPER NAME</a></li>
</ul>
</li>
<li><a href="#%E5%9F%BA%E6%9C%AC%E5%B8%B8%E8%AF%86">基本常识</a></li>
</ul>
</li>
</ul>
</p>
<h2 id="方法综述">方法综述</h2>
<p>目标检测的主流方法是anchor-based，也存在一些anchor-free的尝试。<br>
<strong>anchor-based</strong>：在图片上铺海量的预设anchor，随后对anchor进行种类预测和n次边界回归。通常来说，双阶段方法对边界修正的次数会多于单阶段方法，所以二阶段方法通常有较高的精度，单阶段方法常有较高的计算效率。</p>
<ul>
<li>one-stage<br>
均匀且密集地采样以获得海量候选框，随后进行分类(eg SSD)</li>
<li>two-stage<br>
在筛选过的、稀疏的候选框(滤掉了绝大多数背景/负样本)上进行分类(eg Faster R-CNN)</li>
</ul>
<p><strong>anchor-free</strong>：不使用预设anchor，直接检测物体。</p>
<ul>
<li>keypoint-based<br>
先定位一些预设的/自学习得到的关键点，再依此生成候选框以检测物体(eg Cornernet预测候选框的左上角和右下角点，再进行组合)</li>
<li>center-based<br>
将物体正中心点/中心区域视为正样本，再基于此预测该位置到目标四条边框的距离(eg FCOS将前景框的所有像素点均视为正样本，随后对每个点回归其到框边界的距离)</li>
</ul>
<h2 id="评价指标">评价指标</h2>
<p>mAP</p>
<h2 id="常用数据集">常用数据集</h2>
<p>MS COCO：包含80类物体。数据集划分如下：train有80k图片，val有40k图片。<br>
MSCOCO 2017： training118k validation5k(val) testing about20k无标注(test-dev)<br>
trainval35k部分的115K图片(train的80k图片+)用于训练，minival部分的5k图片用于validation。</p>
<h2 id="指标比对">指标比对</h2>
<p>以COCO数据集AP作为基准指标，比较各方法如下：</p>
<table>
<thead>
<tr>
<th style="text-align:center">ID</th>
<th style="text-align:center">paper</th>
<th style="text-align:center">AP</th>
<th style="text-align:center">AP50</th>
<th style="text-align:center">AP75</th>
<th style="text-align:center">APs</th>
<th style="text-align:center">APm</th>
<th style="text-align:center">APl</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">YOLOF</td>
<td style="text-align:center">37.7</td>
<td style="text-align:center">56.9</td>
<td style="text-align:center">40.6</td>
<td style="text-align:center">19.1</td>
<td style="text-align:center">42.5</td>
<td style="text-align:center">53.2</td>
</tr>
</tbody>
</table>
<h2 id="论文笔记">论文笔记</h2>
<h3 id="1-2021-cvpryolof-you-only-look-one-level-feature">(1) <a href="https://arxiv.org/abs/2103.09460">(2021 CVPR)YOLOF: You Only Look One-level Feature</a></h3>
<ul>
<li>Motivation</li>
</ul>
<p>对RetinaNet的FPN结构做消解实验发现：SiMo仅轻微掉点，故C5特征可能就已涵盖了检测所需要的足够信息；SiMo明显优于MiSo，故分治策略(即多检测头)的重要性远大于融合输入特征的重要性。由上述两点，决定将输入从多输入砍到单输入。<br>
通常认为FPN的核心优势在于多特征融合(multi-scale feature fusion)和分治策略(divide-and-conquer)。本文提出，FPN最大的优势是在密集目标检测时使用分治策略(逐级检测)来进行优化。<br>
<img src="https://FuNian788.github.io/post-images/object_detection/yolof_1.png" alt="RetinaNet-FPN-单多输入-单多输出" loading="lazy"></p>
<p>分治策略可以视为一种优化的方法：将大问题拆分成小问题来解决。但其多头结构降低检测速度，使结构更复杂，带来了更大的空间负担。决定将多输出砍到单输出。</p>
<ul>
<li>主要贡献</li>
</ul>
<p>将FPN简化成单输入(32倍下采样的C5特征)单输出的结构，同时为了弥补SiSo到MiMo的性能差距：</p>
<ol>
<li>
<p>C5特征的感受野大小受限<br>
提出了空洞编码器(Dilated Encoder)来获取多尺度特征</p>
</li>
<li>
<p>Positive anchor对应的GT大小不均衡<br>
提出均衡匹配策略(Uniform Matching)来解决单特征图中稀疏anchor引起的positive anchor不平衡问题。</p>
</li>
</ol>
<p>COCO数据集上，在效果相当的同时，YOLOF可以：<br>
比FPN版本速度快了2.5倍；比DETR的训练轮次少了7倍；比YOLOv4快了13%。</p>
<ul>
<li>
<p>overall<br>
<img src="https://FuNian788.github.io/post-images/object_detection/yolof_2.png" alt="YOLOF结构" loading="lazy"></p>
</li>
<li>
<p>实现细节</p>
</li>
</ul>
<ol>
<li>
<p>空洞编码器<br>
C5特征的感受野很小，只能cover小物体；使用连续的dilated conv疯狂扩展感受野后，只能捕获大物体。故使用残差结构+空洞卷积，使模型既可以捕获小物体，也能捕获大物体。<br>
<img src="https://FuNian788.github.io/post-images/object_detection/yolof_3.png" alt="dilated encoder" loading="lazy"><br>
模型的Projector部分，使用1*1卷积减少通道数，使用3*3卷积修复语义信息；残差块部分使用四个不同dilated rate，不共享参数的block，每个block中，第一个conv降通道数，第二个dilated conv扩大感受野，第三个conv恢复通道数。</p>
</li>
<li>
<p>均衡匹配策略<br>
MiMo模型可以在不同的输出层级上定义不同大小的anchor，然而SiSo模型只有单层输出，对应的anchor数量自然变少。anchor本就容易和大尺度样本有较大的overlap，假设将与任GT bbox的IoU&gt;0.5的anchor定义为positive anchor，那单输入特征图&amp;少anchor时，anchor的不均衡就更为明显：positive anchor主要由大样本占据；模型的重心在大样本上，检出小样本的数量变少。<br>
<img src="https://FuNian788.github.io/post-images/object_detection/yolof_4.png" alt="positive anchor均衡性" loading="lazy"><br>
Uniform Matching：对于每个GT bbox，选取距其最近的K=4个anchor作为positive anchor。<br>
YOLOF在C5 feature的每个位置上构建5个anchor，尺度分别为{32, 64, 128, 256, 512}。</p>
</li>
</ol>
<ul>
<li>改进/Challenge/idea/Que</li>
</ul>
<hr>
<h3 id="2-fairretinanet-focal-loss-for-dense-object-detection">(2) <a href="https://arxiv.org/abs/1708.02002">(FAIR)RetinaNet: Focal Loss for Dense Object Detection</a></h3>
<ul>
<li>Motication<br>
one-stage方法和two-stage方法的核心区别在于：two-stage送去分类器的候选框是稀疏的(过滤了绝大多数背景样本)，而为了实现检测任务，one-stage必须在图片内进行密集的均匀采样，得到未经过滤的候选框并依此去cover所有空间位置。自然地，one-stage这种采样方法得到的候选框中以容易被分类的背景框居多。two-stage方法的候选框大概在1~2k个，one-stage方法的候选框却可达到100k个左右。</li>
</ul>
<p>为什么two-stage方法常常更准呢？本文认为其核心问题在于<strong>训练检测器时样本所属前景-背景类别的不均衡性</strong>(the extreme foreground-background class imbalance encountered during training of dense detectors)。基于此，作者在交叉熵损失函数的基础上提出了Focal Loss，有效阻止海量的、易被分类的背景样本主导训练过程，在对其进行降权的同时，让网络更加关注难样本(更多是正样本)的分类过程。总体来说，当网络对一个样本的预测越准确，该样本对loss的贡献程度越低。</p>
<ul>
<li>
<p>主要贡献<br>
提出Focal Loss来解决正负样本不均衡的问题；基于此提出one-stage的RetinaNet，在保持优良速度的同时具有大幅超过two-stage方法的精度，达到SOTA。</p>
</li>
<li>
<p>overall<br>
对于交叉熵损失函数，在真值类别时，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>L</mi><mi>o</mi><mi>s</mi><mi>s</mi><mo>=</mo><mo>−</mo><mi>l</mi><mi>o</mi><mi>g</mi><mo>(</mo><mi>P</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">Loss = -log(P)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">L</span><span class="mord mathdefault">o</span><span class="mord mathdefault">s</span><span class="mord mathdefault">s</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">−</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mclose">)</span></span></span></span>，在其他类别时，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>L</mi><mi>o</mi><mi>s</mi><mi>s</mi><mo>=</mo><mo>−</mo><mi>l</mi><mi>o</mi><mi>g</mi><mo>(</mo><mn>1</mn><mo>−</mo><mi>P</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">Loss = -log(1 - P)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">L</span><span class="mord mathdefault">o</span><span class="mord mathdefault">s</span><span class="mord mathdefault">s</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">−</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mclose">)</span></span></span></span>。作者认为在此中，简单样本带来的loss不足够小，当简单的背景样本过于多的时候还是可以主宰整个训练过程。为了将训练的注意力集中在难样本上，作者提出了如下图的focal loss。<br>
<img src="https://FuNian788.github.io/post-images/object_detection/retinanet_1.png" alt="positive anchor均衡性" loading="lazy"><br>
假设模型输出概率<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span></span></span></span>。对应地，在两种情况下分析模型处理简单样本的过程：在真值类别下，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span></span></span></span>很大，接近于1，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mi>t</mi></msub><mo>=</mo><mi>P</mi></mrow><annotation encoding="application/x-tex">P_{t} = P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2805559999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span></span></span></span>，这时损失函数的值就超小；在其他类别下，预测得很准时<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span></span></span></span>应该很小，接近于0，此时的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mi>t</mi></msub><mo>=</mo><mn>1</mn><mo>−</mo><mi>P</mi></mrow><annotation encoding="application/x-tex">P_{t} = 1 - P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2805559999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span></span></span></span>还是很大，损失函数仍然很小。反之，处理难样本时的损失函数没有被削减。</p>
</li>
</ul>
<figure data-type="image" tabindex="1"><img src="https://FuNian788.github.io/post-images/object_detection/retinanet_2.png" alt="RetinaNet结构图" loading="lazy"></figure>
<ul>
<li>实现细节</li>
</ul>
<ol>
<li>anchor<br>
在每个位置上，</li>
</ol>
<p>在不同的输出特征图上限制检出物体的大小。</p>
<ul>
<li>改进/Challenge/idea/Que</li>
</ul>
<hr>
<h3 id="3-2019-iccvfcos-fully-convolutional-one-stage-object-detection">(3) <a href="https://arxiv.org/abs/1904.01355">(2019 ICCV)FCOS: Fully Convolutional One-Stage Object Detection</a></h3>
<ul>
<li>针对痛点：</li>
</ul>
<ol>
<li>anchor-based方法需要人为设计框的尺寸及超参数，这些参数的优劣会造成显著地性能差异，且人为设计的候选框很难匹配尺度多变的目标；</li>
<li>anchor-based方法常需要海量的候选框(eg FPN在800见方的图片中需要180K个anchor)，过多的负样本框会造成训练时的样本不平衡；训练时对IoU的不断计算也会导致较大的计算开销；</li>
<li>传统的anchor-free &amp; one-stage方法有<strong>两大弊端</strong>，一是只将anchor中心点所在的网格试做正样本，这种样本不平衡对recall有较大负面影响；一是很难处理重叠物体(anchor方法可很好的解决重叠问题)。</li>
</ol>
<ul>
<li>主要贡献：</li>
</ul>
<ol>
<li>FCN(fully convolutional networks)已其他领域开展得如火如荼，eg语义分割，首在object detection领域基于FCN方法实现的FCOS有助于复用其他领域经验。</li>
<li>anchor-free的FCOS省去了调参的负担，在计算更轻量、训练更容易的同时有着不亚于two-stage/anchor-based方法的精度，启发了对anchor必要性的思考。</li>
<li>提出one-stage的FCN-based网络，提出基于FPN的多尺度预测和center-ness方法，有效解决了当下存在的两大弊端。</li>
</ol>
<ul>
<li>实现流程：<br>
网络的流程图如下所示：<br>
<img src="https://FuNian788.github.io/post-images/TAD/FCOS_1.png" alt="流程图" loading="lazy"><br>
对于单个候选框，每层网络输出一个K维分类label、一个4维距离坐标和一个center-ness得分。该网络较常用的anchor-based方法减少了近9倍的参数量。</li>
<li>实现细节：</li>
</ul>
<ol>
<li>one-stage FCN网络<br>
针对弊端一，FCOS不再只将中心点所在的网格视为正样本，而是将GT bbox所覆盖的所有网格均视为正样本。因此，FCOS舍弃了anchor-based方法中先确定候选框中心位置，再以依此对anchor进行回归的做法，具体地，如下左图所示，对每个前景框的每个点(location)，都预测其到GT bbox的上下左右四条边的距离[t, b, l, r]，该做法与FCN-based方法在语义分割领域的实现思路一致，且值得注意的是，与anchor-based方法仅将与GT bbox有较高IoU的anchor作为正样本相比，FCOS将GT内的所有像素均作为正样本进行训练，无形中获取了更多更准的信息。<br>
<img src="https://FuNian788.github.io/post-images/TAD/FCOS_2.png" alt="示例图" loading="lazy"><br>
对于某层feature map上的location点(x, y)，基于当前层的步长s，先将其映射到原始输入图上的点<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mo>⌊</mo><mfrac><mi>s</mi><mn>2</mn></mfrac><mo>⌋</mo><mo>+</mo><mi>x</mi><mi>s</mi><mo separator="true">,</mo><mo>⌊</mo><mfrac><mi>s</mi><mn>2</mn></mfrac><mo>⌋</mo><mo>+</mo><mi>y</mi><mi>s</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">(\lfloor \frac s2 \rfloor + xs, \lfloor \frac s2 \rfloor + ys)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.095em;vertical-align:-0.345em;"></span><span class="mopen">(</span><span class="mopen">⌊</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.695392em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">⌋</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.095em;vertical-align:-0.345em;"></span><span class="mord mathdefault">x</span><span class="mord mathdefault">s</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mopen">⌊</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.695392em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">⌋</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mord mathdefault">s</span><span class="mclose">)</span></span></span></span>，用映射后的坐标再进行到框边距离的预测，使用指数函数输出四个非负距离量，考虑到不同尺度feature map预测物体大小不同，单纯的指数函数得到距离有失偏颇，FCOS在指数函数中加入可学习参数s(distance = exp(s * x))来适应各个尺度的预测。<br>
损失函数方面，分类方面使用focal loss，坐标回归方面使用IOU loss。</li>
<li>基于FPN的多尺度预测<br>
为解决重叠候选框时的分类问题(如上图右)，anchor-based方法在不同特征尺度设计不同尺寸的候选框，FCOS则遵循FPN的思路，在不同的feature map层检测不同尺度的目标，且<strong>通过阈值直接限制了每一层检出框的尺寸大小</strong>。在FCOS的五个回归branch中，若预测得到的边长长度不符合当前层的长度限制，直接将其视为负样本，这样便粗暴地解决了不同层内目标含有重叠区域的问题。对于同一层内的重叠区域，FCOS直接使用最小的区域作为回归目标(即使同一层内两个同类物体有重叠，小物体会马上被检出，而大物体也定会在未重叠的区域被检出；但不得不说该方法存在理论缺陷，就是同一层内两个不同类物体有重叠，在重叠部分的location可能会返回A物体的种类和B物体的候选框)。依此，FCOS在多尺度预测的同时很好地解决了物体重叠的问题。<br>
如流程图所示，C3、C4、C5是backbone的feature map，通过1*1的卷积层得到P3、P4、P5，而P6和P7则是由P5、P6经过stride为2的卷积层得到的，不同层之间的heads共享权重。<br>
直觉上可能会认为FCOS的BPR(best possible recall，检测器能实现的recall上限，只要有一个anchor涉及到GT框便将其纳入BPR计算范畴内)会受到FCN-based方法中大步长的制约，但实际上FCOS的BPR甚至优于传统的anchor-based方法，所以recall不是FCOS需要着重解决的问题，或者说FPN解决了这一问题。</li>
<li>center-ness分支<br>
在前两步之后，FCOS的性能较anchor-based方法仍有一定的gap，这主要是由一些距物体中心较远的location产生的低质量候选框导致的，FCOS在不引入更多超参数的情况下提出了center-ness分支直接而有效地减少了低质量候选框。<br>
<img src="https://FuNian788.github.io/post-images/TAD/FCOS_3.png" alt="center-ness" loading="lazy"><br>
center-ness的核心思想是，一个GT bbox内的点很多，但它们对目标的贡献是不同的。偏图像中心的点包含了更多的目标信息，理应得到重视；偏图像边界的点包含的信息相对较少，甚至点可能就不在目标上，这些location提出的候选框的质量常较低，理应设置更小的权重。center-ness表征了一个点到其预测候选框中心的距离，其表达式如下所示：</li>
</ol>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi><mi>e</mi><mi>n</mi><mi>t</mi><mi>e</mi><mi>r</mi><mo>−</mo><mi>n</mi><mi>e</mi><mi>s</mi><mi>s</mi><mo>=</mo><msqrt><mrow><mfrac><mrow><mi>m</mi><mi>i</mi><mi>n</mi><mo>(</mo><mi>l</mi><mo separator="true">,</mo><mi>r</mi><mo>)</mo></mrow><mrow><mi>m</mi><mi>a</mi><mi>x</mi><mo>(</mo><mi>l</mi><mo separator="true">,</mo><mi>r</mi><mo>)</mo></mrow></mfrac><mo>∗</mo><mfrac><mrow><mi>m</mi><mi>i</mi><mi>n</mi><mo>(</mo><mi>t</mi><mo separator="true">,</mo><mi>b</mi><mo>)</mo></mrow><mrow><mi>m</mi><mi>a</mi><mi>x</mi><mo>(</mo><mi>t</mi><mo separator="true">,</mo><mi>b</mi><mo>)</mo></mrow></mfrac></mrow></msqrt></mrow><annotation encoding="application/x-tex">center-ness = \sqrt{ \frac {min(l, r)}{max(l, r)} *  \frac {min(t, b)}{max(t, b)} }
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69841em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">e</span><span class="mord mathdefault">n</span><span class="mord mathdefault">t</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">e</span><span class="mord mathdefault">s</span><span class="mord mathdefault">s</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:3.04em;vertical-align:-1.160625em;"></span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.879375em;"><span class="svg-align" style="top:-5em;"><span class="pstrut" style="height:5em;"></span><span class="mord" style="padding-left:1em;"><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.427em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mclose">)</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.936em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.427em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mopen">(</span><span class="mord mathdefault">t</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span><span class="mclose">)</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mopen">(</span><span class="mord mathdefault">t</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.936em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span><span style="top:-3.839375em;"><span class="pstrut" style="height:5em;"></span><span class="hide-tail" style="min-width:1.02em;height:3.08em;"><svg width='400em' height='3.08em' viewBox='0 0 400000 3240' preserveAspectRatio='xMinYMin slice'><path d='M473,2793c339.3,-1799.3,509.3,-2700,510,-2702
c3.3,-7.3,9.3,-11,18,-11H400000v40H1017.7s-90.5,478,-276.2,1466c-185.7,988,
-279.5,1483,-281.5,1485c-2,6,-10,9,-24,9c-8,0,-12,-0.7,-12,-2c0,-1.3,-5.3,-32,
-16,-92c-50.7,-293.3,-119.7,-693.3,-207,-1200c0,-1.3,-5.3,8.7,-16,30c-10.7,
21.3,-21.3,42.7,-32,64s-16,33,-16,33s-26,-26,-26,-26s76,-153,76,-153s77,-151,
77,-151c0.7,0.7,35.7,202,105,604c67.3,400.7,102,602.7,104,606z
M1001 80H400000v40H1017z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.160625em;"><span></span></span></span></span></span></span></span></span></span></p>
<p>当该点为候选框中心时，center-ness的值为1，该点离中心越远，其值越接近0，使用交叉熵损失函数进行训练。center-ness仅在测试时使用，将其与分类得分(classification score)相乘，共同作为候选框的得分，随后进行NMS筛选。</p>
<ul>
<li>对动作检测的启发</li>
</ul>
<ol>
<li>FCN网络结构</li>
<li>动作框预测方式：遍历视频的每一个时刻，返回其到所属动作开始/结束时刻的时间距离</li>
<li>基于FPN的多尺度预测：如果出现了动作套娃(eg运动里套打篮球)，可以考虑使用这种方法来一起检出；其他情况下则不合适，eg峰谷峰时如何只取两个峰。但多尺度思路可以应用于尺度不同的任务。</li>
<li>如果一个候选框和GT的IoU较低，其就是一个低质量候选框，这时如果其confidence得分很高，就是Fasle Positive了。center-ness的应用，可以有效解决当前实践中<strong>置信度最高的候选框可能不是最好的</strong>这一问题。<br>
FCOS认为中心lcoation预测的框是高质量的，边缘location预测的框是低质量的，通过表征location位置的center-ness指标来衡量框的质量，利用其削减低质量候选框得分，从而在NMS阶段保留下真正好的候选框。<br>
在动作检测中，center-ness可以IoU的形式出现，拓展地，可以参考IoUNet新建一个独立的网络去预测候选框和GT的IoU以参与得分评价(FCOS的center-ness计算更为简洁，只是在原有预测基础上进行简单比例计算，并没有涉及神经网络架构)；而如果搭建FCOS-based的动作检测框架，可以直接利用center-ness思路，但要考虑动作并没有明确中心点这一问题。</li>
</ol>
<hr>
<h3 id="4-2020-cvpr-oralatss-bridging-the-gap-between-anchor-based-and-anchor-free-detection-via-adaptive-training-sample-selection">(4) <a href="https://arxiv.org/abs/1912.02424">(2020 CVPR oral)ATSS: Bridging the Gap Between Anchor-based and Anchor-free Detection via Adaptive Training Sample Selection</a></h3>
<ul>
<li>Motivation<br>
对比anchor-based one-stage RetinaNet和anchor-free center-based FCOS，二者有以下三个明显的区别：</li>
</ul>
<ol>
<li>每个像素点(location)处铺设anchor的数量<br>
RetinaNet以每个location为中心位置铺设多个anchor；FCOS视每个location为一个点，再回归该点到该点所在候选框的边界的距离。</li>
<li><strong>定义正负训练样本的方法</strong><br>
RetinaNet将与GT bbox的IoU大于阈值的anchor视为正样本；FCOS将GT bbox内的所有像素点视为正样本。</li>
<li>在何种载体上回归<br>
RetinaNet在铺设的anchor上回归；FCOS在像素点上进行物体定位。<br>
实验表明，性能gap的核心在于第二点。</li>
</ol>
<ul>
<li>主要贡献<br>
首先指出：anchor-based方法和anchor-free方法的本质区别在于<strong>如何定义正负训练样本</strong>，也正是这带来了性能上的差距。如果在训练中使用相同的定义正负样本的方法，那无论是基于box还是point进行回归，最后都不会有显著的性能差异。</li>
</ul>
<p>提出了一种自适应的训练样本筛选策略(ATSS, adaptive training sample selection)来依据目标的统计特征自动地筛选样本。</p>
<ul>
<li>实验过程</li>
</ul>
<ol>
<li>
<p>补齐性能差距<br>
对于mAP，RetinaNet为32.5，FCOS为37.8。为探究anchor-based和anchor-free方法的真正区别，需消除FCOS各种trick对于性能gap的影响：RetinaNet每个像素点处仅许产生一个候选框，再将FCOS的各种trick添加到RetinaNet上(In GT box代表限制GT的正样本数量)：<br>
<img src="https://FuNian788.github.io/post-images/object_detection/ATSS_1.png" alt="RetinaNet FCOS实验结果对比" loading="lazy"><br>
这时的性能：RetinaNet 37.0 vs FCOS 37.8，仍存在0.8个点的差距。此时anchor-based和anchor-free方法仅有两点不同：检测器分类头对于正负样本的定义、检测器回归头是从anchor回归还是从中心点回归。下面对这两点进行进一步实验，探寻到底哪一个才是问题的关键。</p>
</li>
<li>
<p>分类part<br>
RetinaNet在不同的FPN层级使用IoU来定义样本：将每个目标对应的best anchor和IoU大于阈值的anchor标为正样本，将IoU小于阈值的anchor标为负样本，舍弃剩余anchor。<br>
FCOS在不同的FPN层级基于空间位置和目标尺度来定义样本：中心点在GT bbox内的为候选正样本，再基于目标尺度和FPN层级的匹配性从中筛选得到真正的正样本，剩余为负样本。<br>
<img src="https://FuNian788.github.io/post-images/object_detection/ATSS_2.png" alt="RetinaNet FCOS定义正负样本方法" loading="lazy"></p>
</li>
<li>
<p>回归part<br>
RetinaNet回归4个offset(x, y, w, h)，FCOS回归到边界的四个距离(l, r, t, b)。<br>
<img src="https://FuNian788.github.io/post-images/object_detection/ATSS_4.png" alt="RetinaNet FCOS回归方法对比" loading="lazy"></p>
</li>
<li>
<p>性能对比<br>
实验中，只改变了定义样本的方式，但数据可以从多个角度进行分析：<br>
看每一列，回归的方法确定后，RetinaNet和FCOS均会因定义样本的方式而产生较大的性能gap。<br>
<img src="https://FuNian788.github.io/post-images/object_detection/ATSS_3.png" alt="RetinaNet FCOS性能对比" loading="lazy"><br>
以上实验说明，anchor-based和anchor-free方法性能差距的核心在于<strong>训练时定义正负样本的方式不同</strong>。<br>
PS 看每一行，分类时定义正负样本的方法对齐后，尽管回归方式不同，RetinaNet和FCOS(更进一步地，anchor-based和anchor-free)性能却基本相同。</p>
</li>
</ol>
<ul>
<li>
<p>提出改进<br>
FCOS提出的定义正负样本的方法优于之前基于IoU的方法，但这些方法都很依赖超参的设置。本文更进一步地，提出了无超参、鲁棒的、依赖数据特征的定义正负样本新方法ATSS(Adaptive Training Sample Selection)。<br>
<img src="https://FuNian788.github.io/post-images/object_detection/ATSS_5.png" alt="ATSS" loading="lazy"><br>
简要概括：对于GT G，在每一层找k个距其L2距离最近的anchor，组成候选positive anchor的集合P'。随后计算G和P'的IoU，统计其IoU的均值方差并修正，最后保留IoU大于修正值且中心在G内的所有positive anchor，将其组成正样本集合P；剩余的anchor作为负样本。<br>
补充优点：这种方法不会像IoU方法，对大物体表现出明显的青睐，在一定程度上保证了尺度的均衡性。<br>
实验表明，ATSS对于k的大小不敏感，对于anchor的scale和ratio不敏感，具有很好的鲁棒性。</p>
</li>
<li>
<p>实验结果<br>
<img src="https://FuNian788.github.io/post-images/object_detection/ATSS_6.png" alt="ATSS实验结果" loading="lazy"><br>
实验结果表现出了有趣的insight。第一行是原始RetinaNet(每个位置9个anchor)，后几行都是每个位置1个anchor。实验结果表明，对于传统的IoU筛选策略，在每个位置多设置一些anchor是有涨点的(37.0 -&gt; 38.4)。然而在优秀的筛选策略ATSS下，每个位置有一个anchor就够了，设置很多不同scale和ratio的anchor反倒没有什么用。</p>
</li>
<li>
<p>改进/Challenge/idea/Que</p>
</li>
</ul>
<hr>
<h3 id="5-2019-cvprhr-net-deep-high-resolution-representation-learning-for-visual-recognition">(5) <a href="https://arxiv.org/abs/1908.07919">(2019 CVPR)HR-Net: Deep High-Resolution Representation Learning for Visual Recognition</a></h3>
<ul>
<li>
<p>Motivation<br>
现有方法常先使用卷积层将输入编码至low-resolution representation，再从中恢复出high-resolution representation(全流程eg U-Net)。然而高分辨率信息对于position-sensitive的任务十分重要。</p>
</li>
<li>
<p>主要贡献<br>
HR-Net在全阶段都维持了高分辨率表示，从而获取更丰富的语义信息和更准确的空间位置。<br>
核心部件：<br>
(1) <strong>并行</strong>的高分辨率到低分辨率的卷积流(connect the high-to-low resolution convolution streams in parallel)<br>
(2) 重复融合多分辨率流的信息(repreatedly exchange the information across resolutions)</p>
</li>
<li>
<p>overall<br>
如下图所示，第一行一直保持高分辨率信息。四个阶段中，每阶段都在增加稍低分辨率的并行卷积流(一行行增加)，同时通过不同分辨率卷积流的信息交换实现多分辨率融合。<br>
<img src="https://FuNian788.github.io/post-images/object_detection/HR-Net_1.png" alt="overall" loading="lazy"><br>
如下图所示，融合不同分辨率特征的方法是有区别的：高分辨率到低分辨率使用n个stride为2的3*3卷积进行下采样；同分辨率直接相加；低分辨率到高分辨率使用n个(双线性差值+1*1卷积层)实现上采样和通道对齐。<br>
<img src="https://FuNian788.github.io/post-images/object_detection/HR-Net_2.png" alt="信息融合" loading="lazy"></p>
</li>
</ul>
<p>HRNetV1，HRNetV2和HRNetV2p的结构图如下所示。HRNetV1只输出高分辨率流，用于人体姿态估计；HRNetV2将低分辨率流上采样后将四个流的特征叠加起来，用于语义分割；HRNetV2p在HRNetV2的基础上多了下采样的过程，用于目标检测。<br>
<img src="https://FuNian788.github.io/post-images/object_detection/HR-Net_3.png" alt="backbone" loading="lazy"></p>
<ul>
<li>改进/Challenge/idea/Que<br>
Related Work中包含了很多文章，eg如何从低分辨率信息中学习，如何重建高分辨率信息，如何维持高分辨率信息，可以好好学习一下。</li>
</ul>
<hr>
<hr>
<h2 id="基础模型">基础模型</h2>
<h3 id="1-2017-cvprresnext-aggregated-residual-transformations-for-deep-neural-networks">(1) <a href="https://arxiv.org/abs/1611.05431">(2017 CVPR)ResNeXt: Aggregated Residual Transformations for Deep Neural Networks</a></h3>
<ul>
<li>Motivation<br>
VGG &amp; ResNet这类网络通过堆叠相同形状的block来构建深网络，且这种简洁的策略在不同数据集上表现出了优秀的鲁棒性；尽管Inception类网络可以在特定数据上以较低的运算开销展现卓越的性能，但其手工设计痕迹明显，任务迁移时需重新精调网络结构和超参数，成本较高。如何合并这两者？</li>
</ul>
<p>Inception结构通常遵循split-&gt;transform-&gt;merge范式，这是否是Inception成功的关键？(split: 使用许多1*1卷积将输入拆成多个低通道embedding；transform: 使用一些3*3和5*5的卷积来转换信息；merge: 使用通过concate将上述输出综合)</p>
<ul>
<li>
<p>主要贡献<br>
提出ResNeXt，既使用了repeat layer策略(from VGG &amp; ResNet)，又以一种简单、可扩展的方式利用split-transform-merge策略(from Inception)。</p>
</li>
<li>
<p>overall<br>
<img src="https://FuNian788.github.io/post-images/object_detection/ResNeXt_1.png" alt="backbone" loading="lazy"></p>
</li>
<li>
<p>实现细节</p>
</li>
<li>
<p>改进/Challenge/idea/Que</p>
</li>
</ul>
<hr>
<h3 id="n-2021-cvprpaper-name">(n) <a href="https://arxiv.org/abs/2103.09460">(2021 CVPR)PAPER NAME</a></h3>
<ul>
<li>
<p>Motivation</p>
</li>
<li>
<p>主要贡献</p>
</li>
<li>
<p>overall</p>
</li>
<li>
<p>实现细节</p>
</li>
<li>
<p>改进/Challenge/idea/Que</p>
</li>
</ul>
<hr>
<h2 id="基本常识">基本常识</h2>
<ol>
<li>论文中的<code>1x</code>代表以batch size为16，在COCO数据集上训练90k个iter，约为118287张图片上的12.17个epoch。2x等以此类推。</li>
<li>anchor：所有的anchor都参与classification分支的反向传播，此时的损失函数是在K+1类上的交叉熵损失函数，但只有positive anchor才参与regression分支的反向传播。positive的常用定义是IoU阈值，当然也存在一些根据近邻程度的匹配算法。</li>
<li>Anchor的设计存在很多定义方式，但都是在初始anchor(eg 16*16的正方形)上进行变换。<br>
在单feature map上(eg Faster RCNN)，可设定areas和aspect ratio；在多feature map上(eg FPN)，可在aspect ratio和areas之外设定scale。<br>
areas指面积，对应的是边长扩大比例(eg2的3、4、5次幂)，这样可得到原图像上对应的anchor大小eg 128*128，256*256，512*512。aspect ratio是在面积不变的情况下改变长宽比(eg 1:2，1:1，2:1)，以128*128为例可得到eg 184*96，128*128，96*184。这样就有三种面积，每种面积下三种比例，故RPN在每个点处生成9个候选框。<br>
scale指anchor的缩放比例，eg<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mn>0</mn></msup><mi mathvariant="normal">，</mi><msup><mn>2</mn><mrow><mn>1</mn><mi mathvariant="normal">/</mi><mn>3</mn></mrow></msup><mo>=</mo><mn>1.26</mn><mi mathvariant="normal">，</mi><msup><mn>2</mn><mrow><mn>2</mn><mi mathvariant="normal">/</mi><mn>3</mn></mrow></msup><mo>=</mo><mn>1.59</mn></mrow><annotation encoding="application/x-tex">2^{0}，2^{1/3}=1.26，2^{2/3}=1.59</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8879999999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">0</span></span></span></span></span></span></span></span></span><span class="mord cjk_fallback">，</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8879999999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">/</span><span class="mord mtight">3</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8879999999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">.</span><span class="mord">2</span><span class="mord">6</span><span class="mord cjk_fallback">，</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8879999999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mtight">/</span><span class="mord mtight">3</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">.</span><span class="mord">5</span><span class="mord">9</span></span></span></span>。当然这也和FPN中有多种尺度的特征图输出有关。</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[论文阅读 - SALAD: Accurate Temporal Action Proposal Generation with Relation-Aware Pyramid Network]]></title>
        <id>https://FuNian788.github.io/post/salad/</id>
        <link href="https://FuNian788.github.io/post/salad/">
        </link>
        <updated>2021-02-05T06:45:20.000Z</updated>
        <content type="html"><![CDATA[<h3 id="针对痛点">针对痛点</h3>
<ol>
<li>proposal的边界回归都是直接回归一个值，并没有人探索过此回归过程的置信度得分<br>
说白了就是动作边界的回归很难，一些简单的任务，eg目标检测的边界回归就不需要置信度得分，直接用回归值获取bbox的结果就已经很棒了。本文考虑的就是使用回归过程的置信度来优化回归流程。</li>
</ol>
<h3 id="主要贡献">主要贡献</h3>
<ol>
<li>提出联合训练方法：在执行回归任务的同时评估该过程的置信度<br>
自评估模块(self-assessment module)通过注意力线索和多任务正则化(multi-task regularization)方法，可以在训练过程中有效删除低分片段，提升特征质量。<br>
注意力线索：使用置信度修正训练过程，即删除得分较低的侯选框<br>
多任务正则化：指加了评估回归置信度的分支</li>
</ol>
<h3 id="总体思路">总体思路</h3>
<figure data-type="image" tabindex="1"><img src="https://FuNian788.github.io/post-images/TAD/SALAD_2.png" alt="SALAD网络结构图" loading="lazy"></figure>
<ul>
<li>使用I3D提取视频特征；</li>
<li>对于每个时刻t，由双向GRU输出两段分别表征此前所有时刻/此后所有时刻信息的特征；</li>
<li>通过时刻t处得到的两段特征，使用三个并联的全连接模块分别输出包含时刻t的回归后proposal、该回归过程的置信度得分和proposal的动作类别。<br>
注：回归proposal为anchor-free思路，近似于FCOS，直接回归某一时刻点对应的开始、结束时刻。</li>
</ul>
<h3 id="naive自评估边界回归naive-regeression-self-assessment">Naive自评估边界回归(Naive regeression self-assessment)</h3>
<p>不像多分类任务时，模型输出样本属于每一类别的置信度；回归任务中模型只输出回归值，而不评估该过程的置信度。<br>
评估每个侯选框在边界回归过程的得分的Naive方法：使用一个双头网络，一个头执行回归任务，一个头评估我们能否信任这个回归值。这时，这种置信度评估就是一个二分类任务。<br>
对于输入时刻x，其对应的Ground Truth为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>z</mi><mo>(</mo><mi>x</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">{z}(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.04398em;">z</span></span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span>，网络回归结果为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mover accent="true"><mi>z</mi><mo>^</mo></mover><mo>(</mo><mi>x</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">\hat{z}(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.69444em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.04398em;">z</span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.19444em;">^</span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span>，自评估得到的置信度为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mover accent="true"><mi>p</mi><mo>^</mo></mover><mo>(</mo><mi>x</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">\hat{p}(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.69444em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">p</span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.16666em;">^</span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span>，设k为针对回归结果的二值化阈值，则我们可以得到如下损失函数：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mo>=</mo><mi mathvariant="normal">∥</mi><mi>z</mi><mo>(</mo><mi>x</mi><mo>)</mo><mo>−</mo><mover accent="true"><mi>z</mi><mo>^</mo></mover><mo>(</mo><mi>x</mi><mo>)</mo><msubsup><mi mathvariant="normal">∥</mi><mn>2</mn><mn>2</mn></msubsup><mo>+</mo><mi>α</mi><mrow><mo fence="true">[</mo><mtable><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>y</mi><mo>(</mo><mi>x</mi><mo>)</mo><mi>log</mi><mo>⁡</mo><mo>(</mo><mover accent="true"><mi>p</mi><mo>^</mo></mover><mo>(</mo><mi>x</mi><mo>)</mo><mo>)</mo><mo>+</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo>(</mo><mn>1</mn><mo>−</mo><mi>y</mi><mo>(</mo><mi>x</mi><mo>)</mo><mo>)</mo><mi>log</mi><mo>⁡</mo><mo>(</mo><mn>1</mn><mo>−</mo><mover accent="true"><mi>p</mi><mo>^</mo></mover><mo>(</mo><mi>x</mi><mo>)</mo><mo>)</mo></mrow></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow></mrow><annotation encoding="application/x-tex">l=\|z(x)-\hat{z}(x)\|_{2}^{2}+\alpha\left[\begin{array}{c} y(x) \log (\hat{p}(x))+ \\ (1-y(x)) \log (1-\hat{p}(x)) \end{array}\right]
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∥</span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.1141079999999999em;vertical-align:-0.25em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.69444em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.04398em;">z</span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.19444em;">^</span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mord"><span class="mord">∥</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-2.4530000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:2.40003em;vertical-align:-0.95003em;"></span><span class="mord mathdefault" style="margin-right:0.0037em;">α</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">[</span></span><span class="mord"><span class="mtable"><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mopen">(</span><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.69444em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">p</span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.16666em;">^</span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mclose">)</span><span class="mord">+</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.69444em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">p</span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.16666em;">^</span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">]</span></span></span></span></span></span></span></p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>y</mi><mo>(</mo><mi>x</mi><mo>)</mo><mo>=</mo><mn>1</mn><mtext> </mtext><mi>i</mi><mi>f</mi><mtext> </mtext><mi mathvariant="normal">∥</mi><mi>z</mi><mo>(</mo><mi>x</mi><mo>)</mo><mo>−</mo><mover accent="true"><mi>z</mi><mo>^</mo></mover><mo>(</mo><mi>x</mi><mo>)</mo><msubsup><mi mathvariant="normal">∥</mi><mn>2</mn><mn>2</mn></msubsup><mo>&lt;</mo><mi>κ</mi><mtext> </mtext><mi>e</mi><mi>l</mi><mi>s</mi><mi>e</mi><mtext> </mtext><mn>0</mn></mrow><annotation encoding="application/x-tex">y(x) = 1 \ if \ \|z(x)-\hat{z}(x)\|_{2}^{2}&lt;\kappa \ else \ 0  
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mspace"> </span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mspace"> </span><span class="mord">∥</span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.1141079999999999em;vertical-align:-0.25em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.69444em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.04398em;">z</span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.19444em;">^</span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mord"><span class="mord">∥</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-2.4530000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">κ</span><span class="mspace"> </span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">s</span><span class="mord mathdefault">e</span><span class="mspace"> </span><span class="mord">0</span></span></span></span></span></p>
<h3 id="自评估动作检测action-detection-self-assessment">自评估动作检测(Action detection self-assessment)</h3>
<p>论文中自评估动作检测使用如下方法：<br>
构建两个矩阵：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><msub><mi>α</mi><mrow><mi>t</mi><mo separator="true">,</mo><mi>n</mi></mrow></msub><msub><mo>)</mo><mrow><mi>t</mi><mo separator="true">,</mo><mi>n</mi></mrow></msub></mrow><annotation encoding="application/x-tex">(\alpha_{t,n})_{t,n}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.0037em;">α</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.28055599999999997em;"><span style="top:-2.5500000000000003em;margin-left:-0.0037em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">t</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.28055599999999997em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">t</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>矩阵是0-1矩阵，表征N个GT在时长为T的视频上具体的持续时间；<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><msub><mi>y</mi><mi>t</mi></msub><msub><mo>)</mo><mi>t</mi></msub></mrow><annotation encoding="application/x-tex">(y_t)_{t}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2805559999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2805559999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>矩阵是0-1矩阵，表征时长为T的视频中从哪些时刻回归得到的侯选框被选中了。<br>
这两个矩阵的构建思路如下图所示：<br>
<img src="https://FuNian788.github.io/post-images/TAD/SALAD_4.png" alt="矩阵构建思路" loading="lazy"><br>
先根据置信度对所有时刻进行排序，然后遍历所有时刻，再遍历所有GT，为每个GT找且仅找一个tIoU大于阈值的回归侯选框。<br>
对应地，可以基于此构建损失函数：<br>
<img src="https://FuNian788.github.io/post-images/TAD/SALAD_5.png" alt="损失函数" loading="lazy"><br>
此时的损失函数和Naive差不多，主要是把边界点的L2 loss改成了tIoU loss。<br>
自评估动作检测的训练流程如下所示：<br>
<img src="https://FuNian788.github.io/post-images/TAD/SALAD_3.png" alt="自评估动作检测" loading="lazy"><br>
这是一个动态过程，开始时，T时刻全部参与训练；逐渐地，一些潜力不足的时刻由于得分过低被删去。如下图所示，黑色箭头代表五个时刻点生成的五个侯选框，侯选框蓝色的深浅代表网络输出的得分，与任意GT无tIoU的proposal直接被删除(如左图灰色X)，tIoU小于阈值的proposal也逐渐被舍弃(如左图红色X)，一些较好的proposal的边界在逐渐被矫正；右图表示在每次仅优化一个得分最高的侯选框过程中，一些得分在逐渐降低，只有一个的得分在逐渐升高。<br>
这种不断去除较差样本的思路近似于强化学习，即不是所有样本都适合用于全流程训练。</p>
<p>最终的损失函数包括对所有时刻做帧级K+1类动作分类的交叉熵损失函数。</p>
<h3 id="讲故事">讲故事</h3>
<p>故事：置信度可以视为理解算法本身的一种方式；评估自己做的好不好很重要；心理学说，如果可以很好地评估他人的能力有助于增强自身水平。</p>
<p>联合训练和自评估就那么回事，就是多加了一个头，得到当前回归proposal的置信度，但这个置信度很好地被利用到了损失函数构建和训练过程中，这一点论文反倒没有强调。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[常用损失函数合集(Pytorch)]]></title>
        <id>https://FuNian788.github.io/post/Pytorch-loss/</id>
        <link href="https://FuNian788.github.io/post/Pytorch-loss/">
        </link>
        <updated>2020-12-11T07:41:26.000Z</updated>
        <content type="html"><![CDATA[<p>训model嘛，损失函数总是要得。这里简单归纳一下常见的损失函数及其在Pytorch中的使用方法，以便查阅👨‍💻。<br>
<ul class="markdownIt-TOC">
<li>
<ul>
<li>
<ul>
<li><a href="#1-%E4%BA%A4%E5%8F%89%E7%86%B5%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0">1. 交叉熵损失函数</a>
<ul>
<li><a href="#nnlogsoftmax">nn.LogSoftmax()</a></li>
<li><a href="#nnnllloss">nn.NLLLoss()</a></li>
<li><a href="#nncrossentropyloss">nn.CrossEntropyLoss()</a></li>
<li><a href="#%E7%A4%BA%E4%BE%8B">示例</a></li>
</ul>
</li>
<li><a href="#2-%E4%BA%8C%E5%88%86%E7%B1%BB%E4%BA%A4%E5%8F%89%E7%86%B5%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0">2. 二分类交叉熵损失函数</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</p>
<h3 id="1-交叉熵损失函数">1. 交叉熵损失函数</h3>
<p>交叉熵常用于多分类任务，在Pytorch中使用torch.nn.CrossEntropyLoss()函数实现。底层地，该函数是由<code>nn.LogSoftmax()</code>函数和<code>nn.NLLLoss()</code>函数结合得到的。</p>
<h4 id="nnlogsoftmax">nn.LogSoftmax()</h4>
<p>很简单的，<code>nn.LogSoftmax()</code>就是在Softmax()的基础上取对数(ln，以e为底)。</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">LogSoftmax</mi><mo>⁡</mo><mrow><mo fence="true">(</mo><msub><mi>x</mi><mi>i</mi></msub><mo fence="true">)</mo></mrow><mo>=</mo><mi>log</mi><mo>⁡</mo><mrow><mo fence="true">(</mo><mfrac><mrow><mi>exp</mi><mo>⁡</mo><mrow><mo fence="true">(</mo><msub><mi>x</mi><mi>i</mi></msub><mo fence="true">)</mo></mrow></mrow><mrow><munder><mo>∑</mo><mi>j</mi></munder><mi>exp</mi><mo>⁡</mo><mrow><mo fence="true">(</mo><msub><mi>x</mi><mi>j</mi></msub><mo fence="true">)</mo></mrow></mrow></mfrac><mo fence="true">)</mo></mrow></mrow><annotation encoding="application/x-tex">\operatorname{LogSoftmax}\left(x_{i}\right)=\log \left(\frac{\exp \left(x_{i}\right)}{\sum_{j} \exp \left(x_{j}\right)}\right)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop"><span class="mord mathrm">L</span><span class="mord mathrm">o</span><span class="mord mathrm" style="margin-right:0.01389em;">g</span><span class="mord mathrm">S</span><span class="mord mathrm">o</span><span class="mord mathrm" style="margin-right:0.07778em;">f</span><span class="mord mathrm">t</span><span class="mord mathrm">m</span><span class="mord mathrm">a</span><span class="mord mathrm">x</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;">)</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:3.0000299999999998em;vertical-align:-1.25003em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size4">(</span></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.427em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.16195399999999993em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.43581800000000004em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">exp</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;">)</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mop">exp</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.1218180000000002em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size4">)</span></span></span></span></span></span></span></p>
<h4 id="nnnllloss">nn.NLLLoss()</h4>
<p><code>nn.NLLLoss()</code>即负对数似然函数(negative log likelihood loss)，常用于处理K分类问题。该损失函数的输入是对数概率向量和类别标签，适合最后一层是<code>nn.LogSoftmax()</code>的网络。<br>
参考下述代码中loss1及loss2的计算方法去理解：<code>nn.NLLLoss()</code>就是将<code>nn.LogSoftmax()</code>输出中与label对应的值拿出来，去掉负号，再取均值。<br>
以3张图片的5分类任务为例，我们假设label为0,2,4，我们将第一张图片网络输出五个值中的第一个值(index=0)、第二张图片输出的第三个值(index=2)、第三张图片输出的第五个值(index=4)拿出来，将这个三个数取相反数，求平均值，即为负对数似然函数的输出。</p>
<h4 id="nncrossentropyloss">nn.CrossEntropyLoss()</h4>
<h4 id="示例">示例</h4>
<pre><code class="language-Python">import torch
import torch.nn as nn

inputs = torch.randn(3, 5)
label = torch.tensor([0, 2, 4])
print(inputs)
'''
tensor([[-4.0413e-01, -2.3209e+00,  7.4667e-01, -1.5884e-01, -9.4237e-01],
        [ 9.7085e-02,  6.3694e-02, -1.7933e-01,  2.6058e-01, -1.9870e-01],
        [ 1.0408e-01,  5.2098e-05, -9.9802e-01, -2.0989e-01,  1.1665e+00]])
'''

log_softmax = nn.LogSoftmax(dim=1)
net = log_softmax(inputs)
print(net)
'''
tensor([[-1.8196, -3.7364, -0.6688, -1.5743, -2.3579],
        [-1.5363, -1.5697, -1.8127, -1.3728, -1.8321],
        [-1.7677, -1.8717, -2.8698, -2.0817, -0.7052]])
'''

# NLLLoss after LogSoftmax.
nll = nn.NLLLoss()
loss1 = nll(net, label)
print('NLLLoss value after LogSoftmax layer is {}.'.format(loss1))  
# 1.4459

# Simulink the process of NLLLoss.
loss2 = 0.
for i in range(len(label)):
    loss2 += net[i][label[i]]
loss2 = (-1.0) * loss2 / len(label)
print(&quot;Simulink the process of NLLLoss to get loss: {}.&quot;.format(loss2))  
# 1.4459

# CrossEntropyLoss: combination of Softmax, log and NLLLoss.
ce = nn.CrossEntropyLoss()
loss3 = ce(inputs, label)
print(&quot;Loss from CrossEntropyLoss is {}.&quot;.format(loss3))
# 1.4459
</code></pre>
<h3 id="2-二分类交叉熵损失函数">2. 二分类交叉熵损失函数</h3>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[时空动作定位(spatio-temporal action localization)论文总结]]></title>
        <id>https://FuNian788.github.io/post/spatio-temporal-action-localization/</id>
        <link href="https://FuNian788.github.io/post/spatio-temporal-action-localization/">
        </link>
        <updated>2020-11-08T06:24:44.000Z</updated>
        <content type="html"><![CDATA[<p>迫于老板突然改题，匆忙阅读时空动作检测相关论文🤒<br>
<ul class="markdownIt-TOC">
<li>
<ul>
<li><a href="#%E4%BB%BB%E5%8A%A1%E5%AE%9A%E4%B9%89">任务定义</a></li>
<li><a href="#%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E9%9B%86">常用数据集</a></li>
<li><a href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF">应用场景</a></li>
<li><a href="#%E5%AE%9E%E7%8E%B0%E6%80%9D%E8%B7%AF">实现思路</a>
<ul>
<li><a href="#%E6%8C%87%E6%A0%87%E6%AF%94%E5%AF%B9">指标比对</a></li>
</ul>
</li>
<li><a href="#%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB">论文阅读</a>
<ul>
<li><a href="#1-2020-eccvmoc-actions-as-moving-points">(1) (2020 ECCV)MOC: Actions as Moving Points</a></li>
<li><a href="#2-yowo-you-only-watch-once-a-unified-cnn-architecture-for-real-time-spatio-temporal-action-localization">(2) YOWO: you only watch once: A unified CNN architecture for real-time spatio-temporal action localization</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</p>
<h2 id="任务定义">任务定义</h2>
<p>检测视频中所有动作的同时，在时序和空间位置上给出定位。</p>
<h2 id="常用数据集">常用数据集</h2>
<p>UCF101-24：由3207段<strong>未裁剪</strong>的视频组成，涵盖24类运动动作，常使用第一split的视频来衡量动作检测的性能；<br>
JHMDB：由928段<strong>裁剪好</strong>的视频组成，涵盖21类运动动作，常使用前三个split的均值来衡量动作检测的性能。数据集包含单帧层面的人体光流、人体mask、骨骼关节点、动作类别、图像性质(相机运动/可见人体部分/相机视角/人数/视频质量)等。<br>
AVA：每3秒片段仅有一个动作类别标签，主要致力于基于单关键帧的动作检测，且该数据集不适合验证动作管道的性能。<br>
实践中，常采用前两个数据集来衡量时空动作检测的指标。</p>
<h2 id="应用场景">应用场景</h2>
<p>视频监控、事件检测、人机交互、智能安防、异常检测、自动驾驶等</p>
<h2 id="实现思路">实现思路</h2>
<ol>
<li>使用动作检测器在每一帧进行独立检测，再组合各帧检测结果以得到动作管路；或对单一目标检测结果进行进行时序跟踪。这种方法既低效又难以利用时序上下文信息。</li>
<li>使用3D anchor和3D卷积，在视频片段层级执行动作分类和边界回归。此anchor-based方法是目前主流做法，eg人体检测(ResNet50-based Faster RCNN pretrained on ImageNet) +动作分类(I3D/S3D-G pretained on Kinetics + ROI pooling)，但会面临超参多、计算开销极大、动作时序/空间边界不够灵活、缺乏时空上下文连结信息等问题。</li>
<li>基于目标跟踪轨迹线的anchor free动作检测方法，例如MOC。</li>
<li>基于融合时序特征的类目标检测算法，例如YOWO。</li>
</ol>
<h3 id="指标比对">指标比对</h3>
<p>以UCF101-24和JHMDB数据集IoU=0.5作为基准指标，比较各方法的mAP如下：</p>
<table>
<thead>
<tr>
<th style="text-align:center">ID</th>
<th style="text-align:center">paper</th>
<th style="text-align:center">JHMDB Frame mAP</th>
<th style="text-align:center">JHMDB Video mAP</th>
<th style="text-align:center">UCF Frame mAP</th>
<th style="text-align:center">UCF Video mAP</th>
<th style="text-align:center">附注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">MOC</td>
<td style="text-align:center">70.8</td>
<td style="text-align:center">77.2</td>
<td style="text-align:center">78.0</td>
<td style="text-align:center">53.8</td>
<td style="text-align:center">JHMDB averaged three split</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">YOWO(LFB)</td>
<td style="text-align:center">75.7</td>
<td style="text-align:center">85.9</td>
<td style="text-align:center">87.3</td>
<td style="text-align:center">53.1</td>
<td style="text-align:center">JHMDB first split</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">TACNet</td>
<td style="text-align:center">65.5</td>
<td style="text-align:center">73.4</td>
<td style="text-align:center">72.1</td>
<td style="text-align:center">52.9</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">n</td>
<td style="text-align:center">暴力3D sota</td>
<td style="text-align:center">77.9</td>
<td style="text-align:center">80.1</td>
<td style="text-align:center">76.3</td>
<td style="text-align:center">59.9</td>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
<h2 id="论文阅读">论文阅读</h2>
<h3 id="1-2020-eccvmoc-actions-as-moving-points">(1) <a href="https://arxiv.org/abs/2001.04608">(2020 ECCV)MOC: Actions as Moving Points</a></h3>
<ul>
<li>针对痛点：</li>
</ul>
<ol>
<li>基于tubelet的检测器很依赖启发式anchor设计，计算开销大，定位不够精准。</li>
</ol>
<ul>
<li>主要贡献：</li>
</ul>
<ol>
<li>通过将动作实例转换成对一个运动点的轨迹的分析与扩展，实现了高效而精准的检测框架MOC detector。</li>
</ol>
<ul>
<li>实现流程：<br>
MOC实现流程图如下所示：<br>
<img src="https://FuNian788.github.io/post-images/STAD/MOC_2.png" alt="MOC实现流程图" loading="lazy"><br>
（左侧feature提取部分，一次输入K张图片，R表示空间尺度下采样，默认为4，B为卷积后通道数，默认为64；右侧feature下的数字代表N、H、W、C，卷积层下的数字代表输入通道、输出通道、卷积核高度、卷积核宽度)。<br>
模型先将图片输入2D特征提取backbone DLA-34(来自CenterNet，在ImageNet/COCO上预训练)，然后将任务分成三个步骤：</li>
</ul>
<ol>
<li>Center分支：仅在关键帧处尝试找到动作实例中心点的可能位置，并进行动作分类；</li>
<li>Movement分支：通过估计当前帧运动实例中心所在位置与管路中心的offset，实现连续帧内动作中心点的运动估计(将连续帧动作实例中心的移动转化为单点的运行轨迹)；</li>
<li>Box分支：在每帧图像的回归中心处预测当前帧动作bbox的尺寸。<br>
以上三分支可以从短视频片段从提取动作管道，在连结方法的基础上可以实现从长的未裁剪视频进行动作检测。<br>
MOC三阶段示意图如下所示：<br>
<img src="https://FuNian788.github.io/post-images/STAD/MOC_1.png" alt="MOC三阶段示意图" loading="lazy"></li>
</ol>
<ul>
<li>实现细节：</li>
</ul>
<ol>
<li>Center分支：构建大小为W'*H'*C，数值为0至1的热力图，表征关键帧处第C类动作中心在各个空间位置发生的几率。具体地，使用高斯核函数扩张动作中心点GT所在范围；使用focal loss来解决正负样本分布不均衡的问题；筛选策略为：在每一动作类别内，若一点处取值大于等于其八近邻，则将其作为候选；对于一段短视频，仅选取得分最高的N=100个视频进行后续操作。</li>
<li>Movement分支：对K帧连续图像，将其作为整体输入3D卷积层，再输出W'*H'*(k*2)的特征图，等同于为每帧输出W'*H'*2的offset数值，表征每一个中心点处的移动方向；通过Center分支和Movement分支即可得到特定动作中心点的运动轨迹；仅GT所涵盖的中心点处的移动参与反向传播，具体损失函数使用L1。</li>
<li>Box分支：实验表明class-agnostic bbox的产生与时序信息无关，故仅采用当前帧的信息输入Box分支，每一帧输出W'*H'*2的数值，表征每一个中心点处的候选框大小；具体损失函数使用L1。</li>
<li>连结策略：对于任连续的K帧图片，选取动作通道(tubelets)并保留top10作为候选(candidate)；<br>
初始化：对于首帧，每个候选通道开启一个link，对于其他帧，每个与现有link无交集的候选开启一个新link。<br>
连结：一个候选需至少满足三个条件中的一个方可添加到现有link中：1候选并未被其他link选取，2link和候选的交集大于阈值，3候选具有最高的得分。在非首帧时，我们基于link得分的降序将当前帧的候选与现有link相连结(link的得分即使管道所有得分的均值)。<br>
结束：当一个link在连续K帧没被扩展时，将link结束。</li>
<li>补充：以上几分支的损失函数进行均衡；采用尺度变换、位置表换、图像转换等视频数据增强方法；可实现实时动作检测，通过用内存保存前K-1帧的特征来实现；连结策略中的一点是会舍弃过低置信度和过短的动作管道。</li>
</ol>
<ul>
<li>改进/Challenge/idea/Que：</li>
</ul>
<ol>
<li>Center分支：仅在核心帧进行动作实例的中心点检测及动作分类，是不是不够好？应该在每一帧都看才对呀</li>
<li>是不是不够anchor free，一次只能输入一部分frame</li>
<li>Movement分支为什么不是针对类别的？</li>
<li>Box分支为啥没类别？</li>
</ol>
<h3 id="2-yowo-you-only-watch-once-a-unified-cnn-architecture-for-real-time-spatio-temporal-action-localization">(2) <a href="https://arxiv.org/abs/1911.06644">YOWO: you only watch once: A unified CNN architecture for real-time spatio-temporal action localization</a></h3>
<ul>
<li>针对痛点：</li>
</ul>
<ol>
<li>two-stage时空检测方法(tubelet+classification)：依赖人为设计的tubelet，计算开销大，边界难调整；双阶段网络难以全局优化；先检测人框再对3D anchor进行动作分类的方法过分关注人所在处的信息，忽略了背景等语义交互信息；计算开销更大，时间更久，更耗空间。</li>
</ol>
<ul>
<li>主要贡献：</li>
</ul>
<ol>
<li>建立one-stage的实时时空动作检测框架YOWO，一分支通过2D卷积提取当前帧的空间信息，一分支通过3D卷积提取前些帧的时空信息，使用注意力机制和通道融合方法，在融合特征的基础上进行检测任务输出动作种类和人体bbox，在达到sota精度的同时有着较快的检测速度。</li>
</ol>
<ul>
<li>
<p>实现流程：<br>
YOWO实现流程图如下所示，核心部分为3D卷积分支，2D卷积分支，CFAM模块，边界回归模块。<br>
<img src="https://FuNian788.github.io/post-images/STAD/YOWO_1.png" alt="YOWO实现流程图" loading="lazy"></p>
</li>
<li>
<p>实现细节：</p>
</li>
</ul>
<ol>
<li>
<p>特征提取<br>
YOWO用于特征提取的2D/3D分支可使用任何形式的CNN替代，可在考量实时性和性能指标的基础上对其进行替换。<br>
具体地，3D卷积分支使用在Kinetics上预训练的3D-ResNext-101作为backbone，输入视频段<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi><mo>∗</mo><mi>C</mi><mo>∗</mo><mi>H</mi><mo>∗</mo><mi>W</mi><mo separator="true">,</mo><mo>(</mo><mi>C</mi><mo>=</mo><mn>3</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">N*C*H*W,(C=3)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.08125em;">H</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">3</span><span class="mclose">)</span></span></span></span>，选取网络最后一层卷积层输出的特征<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>N</mi><msup><mrow></mrow><mo mathvariant="normal">′</mo></msup></msup><mo>∗</mo><msup><mi>C</mi><msup><mrow></mrow><mo mathvariant="normal">′</mo></msup></msup><mo>∗</mo><msup><mi>H</mi><msup><mrow></mrow><mo mathvariant="normal">′</mo></msup></msup><mo>∗</mo><msup><mi>W</mi><msup><mrow></mrow><mo mathvariant="normal">′</mo></msup></msup><mo separator="true">,</mo><mo>(</mo><msup><mi>N</mi><mo mathvariant="normal">′</mo></msup><mo>=</mo><mn>1</mn><mo separator="true">,</mo><msup><mi>H</mi><mo mathvariant="normal">′</mo></msup><mo>=</mo><mfrac><mi>H</mi><mn>32</mn></mfrac><mo separator="true">,</mo><msup><mi>W</mi><mo mathvariant="normal">′</mo></msup><mo>=</mo><mfrac><mi>W</mi><mn>32</mn></mfrac><mo>)</mo></mrow><annotation encoding="application/x-tex">N^{&#x27;}*C^{&#x27;}*H^{&#x27;}*W^{&#x27;},(N&#x27;=1,H&#x27;=\frac{H}{32}, W&#x27;=\frac{W}{32})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.94248em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.94248em;"><span style="top:-2.94248em;margin-right:0.05em;"><span class="pstrut" style="height:2.57948em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8278285714285715em;"><span style="top:-2.931em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.94248em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.94248em;"><span style="top:-2.94248em;margin-right:0.05em;"><span class="pstrut" style="height:2.57948em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8278285714285715em;"><span style="top:-2.931em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.94248em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.08125em;">H</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.94248em;"><span style="top:-2.94248em;margin-right:0.05em;"><span class="pstrut" style="height:2.57948em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8278285714285715em;"><span style="top:-2.931em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.19248em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.94248em;"><span style="top:-2.94248em;margin-right:0.05em;"><span class="pstrut" style="height:2.57948em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8278285714285715em;"><span style="top:-2.931em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.946332em;vertical-align:-0.19444em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.08125em;">H</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.217331em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.872331em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.08125em;">H</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.217331em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.872331em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">W</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">)</span></span></span></span>；<br>
2D卷积分支使用在PASCAL VOC上预训练的DarkNet-19作为backbone，输入图片<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>C</mi><mo>∗</mo><mi>H</mi><mo>∗</mo><mi>W</mi><mo separator="true">,</mo><mo>(</mo><mi>C</mi><mo>=</mo><mn>3</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">C*H*W,(C=3)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.08125em;">H</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">3</span><span class="mclose">)</span></span></span></span>，输入特征<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>C</mi><msup><mrow></mrow><mrow><mo mathvariant="normal">′</mo><mo mathvariant="normal">′</mo></mrow></msup></msup><mo>∗</mo><msup><mi>H</mi><msup><mrow></mrow><mo mathvariant="normal">′</mo></msup></msup><mo>∗</mo><msup><mi>W</mi><msup><mrow></mrow><mo mathvariant="normal">′</mo></msup></msup><mo separator="true">,</mo><mo>(</mo><msup><mi>H</mi><mo mathvariant="normal">′</mo></msup><mo>=</mo><mfrac><mi>H</mi><mn>32</mn></mfrac><mo separator="true">,</mo><msup><mi>W</mi><mo mathvariant="normal">′</mo></msup><mo>=</mo><mfrac><mi>W</mi><mn>32</mn></mfrac><mo>)</mo></mrow><annotation encoding="application/x-tex">C^{&#x27;&#x27;}*H^{&#x27;}*W^{&#x27;},(H&#x27;=\frac{H}{32}, W&#x27;=\frac{W}{32})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.94248em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.94248em;"><span style="top:-2.94248em;margin-right:0.05em;"><span class="pstrut" style="height:2.57948em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8278285714285715em;"><span style="top:-2.931em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">′</span><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.94248em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.08125em;">H</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.94248em;"><span style="top:-2.94248em;margin-right:0.05em;"><span class="pstrut" style="height:2.57948em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8278285714285715em;"><span style="top:-2.931em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.19248em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.94248em;"><span style="top:-2.94248em;margin-right:0.05em;"><span class="pstrut" style="height:2.57948em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8278285714285715em;"><span style="top:-2.931em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.08125em;">H</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.217331em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.872331em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.08125em;">H</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.217331em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.872331em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">W</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">)</span></span></span></span>。<br>
两分支联合训练；使用StepLR策略；采用图像增强算法例如水平翻转、随机放缩、随机裁剪；使用阈值筛选bbox得分并通过NMS；鉴于数据集过小，在训练J-HMDB-21数据集时冻结了3D卷积的网络参数以加速收敛、避免过拟合。<br>
从实验结果分析，2D网络更擅长定位任务(localization)，3D网络更擅长分类任务。从activation map角度分析，2D网络关注图像内所有的人，3D网络关注正在进行动作的发生位置。</p>
</li>
<li>
<p>特征融合CFAM(channel fusion and attension mechansim)</p>
</li>
</ol>
<p>补充知识：n维欧式空间中任意k个向量之间两两的内积所组成的矩阵，称为这k个向量的格拉姆矩阵(Gram matrix)，Gram矩阵可反映出一组向量中各个向量之间的关系。</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">Δ</mi><mrow><mo fence="true">(</mo><msub><mi>α</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>α</mi><mn>2</mn></msub><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><msub><mi>α</mi><mi>k</mi></msub><mo fence="true">)</mo></mrow><mo>=</mo><mrow><mo fence="true">(</mo><mtable><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo fence="true">(</mo><msub><mi>α</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>α</mi><mn>1</mn></msub><mo fence="true">)</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo fence="true">(</mo><msub><mi>α</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>α</mi><mn>2</mn></msub><mo fence="true">)</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mo>…</mo></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo fence="true">(</mo><msub><mi>α</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>α</mi><mi>k</mi></msub><mo fence="true">)</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo fence="true">(</mo><msub><mi>α</mi><mn>2</mn></msub><mo separator="true">,</mo><msub><mi>α</mi><mn>1</mn></msub><mo fence="true">)</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo fence="true">(</mo><msub><mi>α</mi><mn>2</mn></msub><mo separator="true">,</mo><msub><mi>α</mi><mn>2</mn></msub><mo fence="true">)</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mo>…</mo></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo fence="true">(</mo><msub><mi>α</mi><mn>2</mn></msub><mo separator="true">,</mo><msub><mi>α</mi><mi>k</mi></msub><mo fence="true">)</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mo>…</mo></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mo>…</mo></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mo>…</mo></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mo>…</mo></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo fence="true">(</mo><msub><mi>α</mi><mi>k</mi></msub><mo separator="true">,</mo><msub><mi>α</mi><mn>1</mn></msub><mo fence="true">)</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo fence="true">(</mo><msub><mi>α</mi><mi>k</mi></msub><mo separator="true">,</mo><msub><mi>α</mi><mn>2</mn></msub><mo fence="true">)</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mo>…</mo></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo fence="true">(</mo><msub><mi>α</mi><mi>k</mi></msub><mo separator="true">,</mo><msub><mi>α</mi><mi>k</mi></msub><mo fence="true">)</mo></mrow></mstyle></mtd></mtr></mtable><mo fence="true">)</mo></mrow></mrow><annotation encoding="application/x-tex">\Delta\left(\alpha_{1}, \alpha_{2}, \ldots, \alpha_{k}\right)=\left(\begin{array}{cccc}
\left(\alpha_{1}, \alpha_{1}\right) &amp; \left(\alpha_{1}, \alpha_{2}\right) &amp; \ldots &amp; \left(\alpha_{1}, \alpha_{k}\right) \\
\left(\alpha_{2}, \alpha_{1}\right) &amp; \left(\alpha_{2}, \alpha_{2}\right) &amp; \ldots &amp; \left(\alpha_{2}, \alpha_{k}\right) \\
\ldots &amp; \ldots &amp; \ldots &amp; \ldots \\
\left(\alpha_{k}, \alpha_{1}\right) &amp; \left(\alpha_{k}, \alpha_{2}\right) &amp; \ldots &amp; \left(\alpha_{k}, \alpha_{k}\right)
\end{array}\right)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">Δ</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.0037em;">α</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.0037em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.0037em;">α</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.0037em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.0037em;">α</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.0037em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;">)</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:4.80006em;vertical-align:-2.15003em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6500299999999997em;"><span style="top:-1.6499900000000003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎝</span></span></span><span style="top:-2.805em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎜</span></span></span><span style="top:-3.4050100000000003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎜</span></span></span><span style="top:-4.65003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎛</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.15003em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6500000000000004em;"><span style="top:-4.8100000000000005em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.0037em;">α</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.0037em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.0037em;">α</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.0037em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;">)</span></span></span></span><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.0037em;">α</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.0037em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.0037em;">α</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.0037em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;">)</span></span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="minner">…</span></span></span><span style="top:-1.2099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.0037em;">α</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.0037em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.0037em;">α</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.0037em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.1500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6500000000000004em;"><span style="top:-4.8100000000000005em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.0037em;">α</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.0037em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.0037em;">α</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.0037em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;">)</span></span></span></span><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.0037em;">α</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.0037em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.0037em;">α</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.0037em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;">)</span></span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="minner">…</span></span></span><span style="top:-1.2099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.0037em;">α</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.0037em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.0037em;">α</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.0037em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.1500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6500000000000004em;"><span style="top:-4.8100000000000005em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="minner">…</span></span></span><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="minner">…</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="minner">…</span></span></span><span style="top:-1.2099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="minner">…</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.1500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6500000000000004em;"><span style="top:-4.8100000000000005em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.0037em;">α</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.0037em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.0037em;">α</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.0037em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;">)</span></span></span></span><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.0037em;">α</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.0037em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.0037em;">α</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.0037em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;">)</span></span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="minner">…</span></span></span><span style="top:-1.2099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.0037em;">α</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.0037em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.0037em;">α</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.0037em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.1500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span></span></span><span class="mclose"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6500299999999997em;"><span style="top:-1.6499900000000003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎠</span></span></span><span style="top:-2.805em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎟</span></span></span><span style="top:-3.4050100000000003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎟</span></span></span><span style="top:-4.65003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎞</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.15003em;"><span></span></span></span></span></span></span></span></span></span></span></span></p>
<p>例如输入图像的特征维度为(C, H, W)，通过flatten可得到(C, H*W)形式的矩阵，对该矩阵做内积，即将其与转置得到的(H*W, C)型矩阵做矩阵乘法，即得到(C, C)形式的Gram矩阵(显然Gram矩阵是一个对称矩阵)。<br>
Gram矩阵可以看作特征之间的偏心协方差矩阵(未减去均值故偏心)。Gram矩阵第(i, j)个元素表示通道i特征和通道j特征的内积，故其可以代表i和j通道特征的相关程度，例如特征同时出现/此消彼长的程度等。<br>
Gram可应用于风格迁移中，例如以原图和风格图像feature map对应的Gram矩阵差异化最小为目标进行优化，最近也有了在分割任务中的应用。<br>
将2D分支和3D分支输出的特征沿通道叠加，流程如下图所示：<br>
<img src="https://FuNian788.github.io/post-images/STAD/YOWO_2.png" alt="CFAM特征融合" loading="lazy"><br>
特征C是由特征B的原始特征加上计算的通道权重得到的。将B至C的四条线分别认为是1~4步，则3、4步即为Gram矩阵计算过程，其中3输出(C, H*W)的矩阵，4输出(H*W, C)的矩阵，但随后进行softmax归一化操作以得到矩阵M(C, C)；M矩阵与2输出的(C, H*W)矩阵点乘，再reshape得到(C, H, W)的矩阵F，最终C矩阵为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>C</mi><mo>=</mo><mi>α</mi><mi>F</mi><mo>+</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">C = \alpha F+B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.0037em;">α</span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">\alpha</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.0037em;">α</span></span></span></span>为从0开始学习的参数。<br>
注意，前后的两层卷积层可以对2D分支、3D分支这样来自不同backbone，可能有分布差异的特征进行融合。CFAM的性能提升是显著的，但如果没有这四层卷积层，性能只有小幅提升。</p>
<ol start="3">
<li>bbox连结策略(linking strategy)<br>
采用通用连结策略：</li>
</ol>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>s</mi><mi>c</mi></msub><mrow><mo fence="true">(</mo><msub><mi>R</mi><mi>t</mi></msub><mo separator="true">,</mo><msub><mi>R</mi><mrow><mi>t</mi><mo>+</mo><mn>1</mn></mrow></msub><mo fence="true">)</mo></mrow><mo>=</mo><mi>ψ</mi><mo>(</mo><mi>o</mi><mi>v</mi><mo>)</mo><mo>⋅</mo><mrow><mo fence="true">[</mo><msub><mi>s</mi><mi>c</mi></msub><mrow><mo fence="true">(</mo><msub><mi>R</mi><mi>t</mi></msub><mo fence="true">)</mo></mrow><mo>+</mo><msub><mi>s</mi><mi>c</mi></msub><mrow><mo fence="true">(</mo><msub><mi>R</mi><mrow><mi>t</mi><mo>+</mo><mn>1</mn></mrow></msub><mo fence="true">)</mo></mrow></mrow><mo>+</mo><mi>α</mi><mo>⋅</mo><msub><mi>s</mi><mi>c</mi></msub><mrow><mo fence="true">(</mo><msub><mi>R</mi><mi>t</mi></msub><mo fence="true">)</mo></mrow><mo>⋅</mo><msub><mi>s</mi><mi>c</mi></msub><mrow><mo fence="true">(</mo><msub><mi>R</mi><mrow><mi>t</mi><mo>+</mo><mn>1</mn></mrow></msub><mo fence="true">)</mo></mrow><mrow><mo>+</mo><mi>β</mi><mo>⋅</mo><mi>o</mi><mi>v</mi><mrow><mo fence="true">(</mo><msub><mi>R</mi><mi>t</mi></msub><mo separator="true">,</mo><msub><mi>R</mi><mrow><mi>t</mi><mo>+</mo><mn>1</mn></mrow></msub><mo fence="true">)</mo></mrow><mo fence="true">]</mo></mrow></mrow><annotation encoding="application/x-tex">s_{c}\left(R_{t}, R_{t+1}\right)= \psi(o v) \cdot\left[s_{c}\left(R_{t}\right)+s_{c}\left(R_{t+1}\right)\right.
+\alpha \cdot s_{c}\left(R_{t}\right) \cdot s_{c}\left(R_{t+1}\right) 
\left.+\beta \cdot o v\left(R_{t}, R_{t+1}\right)\right]
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">c</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2805559999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.00773em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:-0.00773em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">t</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;">)</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">ψ</span><span class="mopen">(</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">[</span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">c</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2805559999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.00773em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;">)</span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">c</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:-0.00773em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">t</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;">)</span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.44445em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.0037em;">α</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">c</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2805559999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.00773em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;">)</span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">c</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:-0.00773em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">t</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;">)</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen nulldelimiter"></span><span class="mord">+</span><span class="mord mathdefault" style="margin-right:0.05278em;">β</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2805559999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.00773em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:-0.00773em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">t</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;">)</span></span><span class="mclose delimcenter" style="top:0em;">]</span></span></span></span></span></span></p>
<p>其中<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>R</mi><mi>t</mi></msub></mrow><annotation encoding="application/x-tex">R_{t}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2805559999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.00773em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>代表t时刻检测区域；<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>R</mi><mrow><mi>t</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">R_{t+1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.891661em;vertical-align:-0.208331em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:-0.00773em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">t</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span></span></span></span>代表t+1时刻检测区域；<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>o</mi><mi>v</mi></mrow><annotation encoding="application/x-tex">o v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span></span></span></span>代表两个区域的IoU值；<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>ψ</mi><mo>(</mo><mi>o</mi><mi>v</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">\psi(o v)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">ψ</span><span class="mopen">(</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mclose">)</span></span></span></span>为单值函数，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>o</mi><mi>v</mi></mrow><annotation encoding="application/x-tex">o v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span></span></span></span>为0时为0，其余相交时刻为1；<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>s</mi><mi>c</mi></msub></mrow><annotation encoding="application/x-tex">s_{c}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">c</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>代表c类别动作的得分。<br>
在得到所有两两图像的连结得分后，使用Viterbi算法寻找最优路径以得到动作管道tubelet。</p>
<ol start="4">
<li>
<p>长时特征存储(Long-Term Feature Bank)<br>
YOWO仅输入当前时刻之前的短时频段(8/16帧)以保证实时性，但也可利用较长的前后视频特征以提高性能。在3D分支处，LFB方法使用以当前帧为中心的8个特征平均后的结果作为CFAM模块的输入(每个特征是由8帧图像得到的，相当于共利用了前后共64帧的信息)。该方法在损伤实时性的同时却显著提高了效果。</p>
</li>
<li>
<p>3D网络输入视频帧数及降采样频率<br>
<img src="https://FuNian788.github.io/post-images/STAD/YOWO_3.png" alt="降采样" loading="lazy"><br>
如图，作者做了详细的实验，eg frame-8 &amp; d-3代表从24帧中采样8帧。16帧效果较好因为其包括了更多的时序信息，降采样频率较大效果不好是因为可能没有很好地捕获动作模式，且过长的序列可能破坏时序结构(eg对于较短的动作而言，较长的序列可能包含许多不相干的信息)。</p>
</li>
<li>
<p>bbox回归<br>
沿袭YOLO的结构，在<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>H</mi><msup><mrow></mrow><mo mathvariant="normal">′</mo></msup></msup><mo>∗</mo><msup><mi>W</mi><msup><mrow></mrow><mo mathvariant="normal">′</mo></msup></msup></mrow><annotation encoding="application/x-tex">H^{&#x27;}*W^{&#x27;}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.94248em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.08125em;">H</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.94248em;"><span style="top:-2.94248em;margin-right:0.05em;"><span class="pstrut" style="height:2.57948em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8278285714285715em;"><span style="top:-2.931em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.94248em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.94248em;"><span style="top:-2.94248em;margin-right:0.05em;"><span class="pstrut" style="height:2.57948em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8278285714285715em;"><span style="top:-2.931em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>的每个grid处，设计5个先验框，输出<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mn>5</mn><mo>+</mo><mi>n</mi><mi>u</mi><msub><mi>m</mi><mi>c</mi></msub><mi>l</mi><mi>a</mi><mi>s</mi><mi>s</mi><mo>)</mo><mo>∗</mo><msup><mi>H</mi><msup><mrow></mrow><mo mathvariant="normal">′</mo></msup></msup><mo>∗</mo><msup><mi>W</mi><msup><mrow></mrow><mo mathvariant="normal">′</mo></msup></msup></mrow><annotation encoding="application/x-tex">(5+num_class)*H^{&#x27;}*W^{&#x27;}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">5</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord"><span class="mord mathdefault">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">c</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">a</span><span class="mord mathdefault">s</span><span class="mord mathdefault">s</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.94248em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.08125em;">H</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.94248em;"><span style="top:-2.94248em;margin-right:0.05em;"><span class="pstrut" style="height:2.57948em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8278285714285715em;"><span style="top:-2.931em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.94248em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.94248em;"><span style="top:-2.94248em;margin-right:0.05em;"><span class="pstrut" style="height:2.57948em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8278285714285715em;"><span style="top:-2.931em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>，其中5代表xywh的offset和confidence score。<br>
具体地，使用多尺度训练，测试时将图片压缩至224*224；使用SGD+momentum+weight decay济宁训练；使用smooth L1损失函数以定位(对于坏点较L2更不敏感)；使用focal loss以分类。</p>
</li>
</ol>
<ul>
<li>改进/Challenge/idea/Que：</li>
</ul>
<ol>
<li>光流去哪里了</li>
<li>时序因果卷积可以加载哪里</li>
<li>作者认为，YOWO获取了过多的前置信息以至于有时会在动作开始前便给出高置信度，flase positive，这个是不是可以和我的时序方法综合一下，例如我输出score结果来辅助一下。<br>
同时作者认为，YOWO需要很多前置信息，以至于动作刚开始时容易判断错类别。<br>
我觉得这部分的工作可以很好地和proposal的score思路进行结合。·</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Pytorch Debug小记]]></title>
        <id>https://FuNian788.github.io/post/pytorch-debug/</id>
        <link href="https://FuNian788.github.io/post/pytorch-debug/">
        </link>
        <updated>2020-10-21T04:44:40.000Z</updated>
        <content type="html"><![CDATA[<p><ul class="markdownIt-TOC">
<li>
<ul>
<li>
<ul>
<li><a href="#thcunnbcecriterioncu42-assertion-input-0-input-1-failed">THCUNN/BCECriterion.cu:42: Assertion `input &gt;= 0. &amp;&amp; input &lt;= 1.` failed.</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</p>
<h3 id="thcunnbcecriterioncu42-assertion-input-0-input-1-failed">THCUNN/BCECriterion.cu:42: Assertion `input &gt;= 0. &amp;&amp; input &lt;= 1.` failed.</h3>
<p>直接原因：torch.nn.BSEloss()函数输入值不在0-1的范围内<br>
根本原因：网络参数运算过程中出现NAN数值破坏最终结果<br>
bug定位过程：<br>
初始化模型后，第一个epoch即有一定几率报错，排查数据后，将学习率设置为1e-10时仍可偶尔复现该错误，故排除模型训飞(反向传播时偶有极大梯度，在部分层处发生梯度爆炸)；<br>
猜测是模型初始化问题，舍弃框架原有初始化方式，改用kaiming_normal方法，错误仍产生，排除初始化参数时造成的NAN；<br>
模型最后一层为Sigmoid，原则上会限制输入在0-1范围内，故得知NAN发生在模型运行中，才发生了Sigmoid(tensor(NAN))==NAN的错误；<br>
猜测是LayerNorm连续遇到不同类型数据，通过线性放缩将模型带飞，将batch_size从2改到16，问题消失。<br>
补充思路：<br>
使用binary_cross_entropy_with_logits函数替代Sigmoid+BSEloss()函数；<br>
使用torch.clamp(0,1)将数据限制在特定范围内(不靠谱)；<br>
使用x = torch.where(torch.isnan(x), torch.zeros_like(x), x)将数据限制在特定范围内(不靠谱)；<br>
补充知识：<br>
Pytorch的torch.nn.BSEloss()函数在求梯度时进行截断操作，最多仅能传递-100的梯度；</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[一文详解Pytorch中view()和reshape()的区别]]></title>
        <id>https://FuNian788.github.io/post/pytorch-view-reshape/</id>
        <link href="https://FuNian788.github.io/post/pytorch-view-reshape/">
        </link>
        <updated>2020-09-22T11:39:12.000Z</updated>
        <content type="html"><![CDATA[<p><ul class="markdownIt-TOC">
<li>
<ul>
<li>
<ul>
<li><a href="#torchview">torch.view()</a></li>
<li><a href="#torchreshape">torch.reshape()</a></li>
<li><a href="#pytorch%E4%B8%8Etensorflow%E5%AF%B9%E6%AF%94">Pytorch与TensorFlow对比</a></li>
<li><a href="#%E6%80%BB%E7%BB%93">总结</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</p>
<p>Pytorch中主要使用<code>view()</code>与<code>reshape()</code>来改变tensor的shape。</p>
<h3 id="torchview">torch.view()</h3>
<p><code>torch.view()</code>通过<strong>共享内存地址</strong>的方式使用原tensor的基础数据，通过改变数据读取方式来返回一个具有新shape的新tensor；只能使用<code>torch.Tensor.view()</code>方式调用；在使用时要求新shape与原shape的尺寸兼容，即函数只能应用于<strong>内存中连续存储</strong>的tensor，使用<code>transpose</code>、<code>permute</code>等函数改变tensor在内存内连续性后需使用<code>contiguous()</code>方法返回拷贝后的值再调用该函数。<br>
可参照下例辅助理解：</p>
<pre><code class="language-Python">import torch

a = torch.arange(24).view(1,2,3,4)
b = a.view(1,3,2,4)     # b.shape: 1 * 3 * 2 * 4  
c = a.transpose(1,2)    # c.shape: 1 * 3 * 2 * 4
# d = c.view(2, 12)     # raise error because of the uncontinuous data.
d = c.contiguous().view(2, 12)
print(b)
'''
tensor([[[[ 0,  1,  2,  3],
          [ 4,  5,  6,  7]],

         [[ 8,  9, 10, 11],
          [12, 13, 14, 15]],

         [[16, 17, 18, 19],
          [20, 21, 22, 23]]]])
'''
print(c)
'''
tensor([[[[ 0,  1,  2,  3],
          [12, 13, 14, 15]],

         [[ 4,  5,  6,  7],
          [16, 17, 18, 19]],

         [[ 8,  9, 10, 11],
          [20, 21, 22, 23]]]])
'''
print(id(b) == id(c))           # False
print(id(b.data) == id(c.data)) # True

b[0, 0, :, :] = 100
print(a, b) # 'a' will also change its data.
</code></pre>
<h3 id="torchreshape">torch.reshape()</h3>
<p><code>torch.reshape()</code>通过拷贝并使用原tensor的基础数据(而<strong>非共享内存地址</strong>)以返回一个具有新shape的新tensor；可使用<code>torch.reshape()</code>或<code>torch.Tensor.reshape()</code>方法调用。此函数不依赖tensor在内存的连续性，当内存连续时，该函数与<code>torch.view()</code>函数等价，当内存不连续时，会自动复制后再改变形状，相当于<code>contiguous().view()</code>。此函数于Pytorch0.4时加入，解决了之前只有<code>view</code>函数时的部分遗留问题。<br>
可参照下例辅助理解：</p>
<pre><code class="language-Python">import torch
a = torch.zeros(3, 2)
b = a.reshape(6)
c = a.t().reshape(6)
a.fill_(1)
print(b)    # tensor([1., 1., 1., 1., 1., 1.])
print(c)    # tensor([0., 0., 0., 0., 0., 0.])
</code></pre>
<h3 id="pytorch与tensorflow对比">Pytorch与TensorFlow对比</h3>
<p>对Pytorch中view函数和reshape函数的执行方式深入分析：在此过程中内存中数据分布并不发生改变，仅仅是数据读取方式发生了改变，更像是开创了一个特定shape的数组后单纯地将内存中数据逐个填入。<br>
对比一下Pytorch和TensorFlow在更改tensor形状时的要求：假设我们有一个6*8大小的矩阵，希望将其转换成2*8*3的形状，TensorFlow会要求先将其拆成2*3*8再转成2*8*3；而Pytorch中可以直接转换而不报错，但这样的结果显然与我们想要的相去甚远，如果要正确转换格式，还是要先调换维度，再reshape/view。<br>
一言以蔽之，Pytorch中改变矩阵shape的门槛更低，但也正是因此，更容易出错，对coder提出了更高的要求。<br>
参照下例：</p>
<pre><code class="language-Python">import torch

a = torch.zeros(6,5)
for i in range(6):
    a[i,:] = i
print(a)
&quot;&quot;&quot;
tensor([[0., 0., 0., 0., 0.],
        [1., 1., 1., 1., 1.],
        [2., 2., 2., 2., 2.],
        [3., 3., 3., 3., 3.],
        [4., 4., 4., 4., 4.],
        [5., 5., 5., 5., 5.]])
&quot;&quot;&quot;

b = a.view(2,5,3)
c = a.reshape(2,5,3)
print(b, c)
&quot;&quot;&quot;
'b' is same as 'c', which is as below:
tensor([[[0., 0., 0.],
         [0., 0., 1.],
         [1., 1., 1.],
         [1., 2., 2.],
         [2., 2., 2.]],

        [[3., 3., 3.],
         [3., 3., 4.],
         [4., 4., 4.],
         [4., 5., 5.],
         [5., 5., 5.]]])
&quot;&quot;&quot;
d = a.reshape(2,3,5).transpose(1,2)
print(d)
&quot;&quot;&quot;
tensor([[[0., 1., 2.],
         [0., 1., 2.],
         [0., 1., 2.],
         [0., 1., 2.],
         [0., 1., 2.]],

        [[3., 4., 5.],
         [3., 4., 5.],
         [3., 4., 5.],
         [3., 4., 5.],
         [3., 4., 5.]]])
&quot;&quot;&quot;

</code></pre>
<h3 id="总结">总结</h3>
<p>如果需要新tensor，使用<code>copy()</code>；如果需要共享内存，使用<code>view()</code>；无脑<code>reshape()</code>不可取。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Ubuntu杂记]]></title>
        <id>https://FuNian788.github.io/post/ubuntu-misc/</id>
        <link href="https://FuNian788.github.io/post/ubuntu-misc/">
        </link>
        <updated>2020-09-17T03:22:24.000Z</updated>
        <content type="html"><![CDATA[<p><ul class="markdownIt-TOC">
<li>
<ul>
<li>
<ul>
<li><a href="#ubuntu%E5%9C%A8%E5%BD%93%E5%89%8D%E7%9B%AE%E5%BD%95%E5%8F%8A%E5%AD%90%E7%9B%AE%E5%BD%95%E5%AF%BB%E6%89%BE%E6%96%87%E4%BB%B6">Ubuntu在当前目录及子目录寻找文件</a></li>
<li><a href="#ubuntu%E6%9F%A5%E7%9C%8B%E6%96%87%E4%BB%B6%E5%A4%B9%E5%86%85%E6%96%87%E4%BB%B6%E6%95%B0%E9%87%8F">Ubuntu查看文件夹内文件数量</a></li>
<li><a href="#%E6%9F%A5%E7%9C%8B%E8%BF%9B%E7%A8%8B">查看进程</a></li>
<li><a href="#%E6%9D%80%E6%AD%BB%E8%BF%9B%E7%A8%8B">杀死进程</a></li>
<li><a href="#%E6%B8%85%E5%8D%8E%E6%BA%90pip">清华源pip</a></li>
<li><a href="#pandas%E8%AF%BB%E5%8F%96csv%E8%A1%A8">pandas读取csv表</a></li>
<li><a href="#%E5%A6%82%E4%BD%95%E8%BF%9Bdocker%E5%86%85%E9%83%A8%E8%B0%83%E8%AF%95">如何进docker内部调试</a></li>
<li><a href="#gitignore%E6%97%A0%E6%B3%95%E7%94%9F%E6%95%88">.gitignore无法生效</a></li>
<li><a href="#%E5%AE%B9%E5%99%A8%E5%AE%89%E8%A3%85tmux">容器安装tmux</a></li>
<li><a href="#%E6%9F%A5%E7%9C%8B%E6%96%87%E4%BB%B6%E8%A1%8C%E6%95%B0">查看文件行数</a></li>
<li><a href="#mac%E5%B0%86pdf%E8%BD%AC%E6%8D%A2%E4%B8%BA%E8%A3%81%E5%89%AA%E8%BE%B9%E7%9A%84eps">Mac将pdf转换为裁剪边的eps</a></li>
<li><a href="#%E6%9F%A5%E7%9C%8B%E6%96%87%E4%BB%B6%E6%95%B0%E9%87%8F">查看文件数量</a></li>
<li><a href="#%E7%A3%81%E7%9B%98%E5%AE%B9%E9%87%8F%E6%A3%80%E6%B5%8B">磁盘容量检测</a></li>
<li><a href="#hadoop">Hadoop</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</p>
<h3 id="ubuntu在当前目录及子目录寻找文件">Ubuntu在当前目录及子目录寻找文件</h3>
<p>以检索所有xml文件为例：</p>
<pre><code class="language-Shell">sudo find | grep -i .*[.]xml
</code></pre>
<p>在检索指令grep中， <code>-i</code>表示忽略大小写， <code>.*</code> 两个组合表示匹配任意字符，<code>[.]</code>表示xml前强制匹配<code>.</code>。<br>
在特定路径查找特定名称的文件可如下例：</p>
<pre><code class="language-Shell">find /opt/tiger -name 'xgb.mode*l' -print`
</code></pre>
<h3 id="ubuntu查看文件夹内文件数量">Ubuntu查看文件夹内文件数量</h3>
<p>以下所称“文件”是目录、链接、设备文件等的总称。<br>
查看当前目录下文件数量(<strong>不包含</strong>子目录中的文件)，也就是<code>ls</code>指令后弹出的文件数量：</p>
<pre><code class="language-Shell">ls -l | grep &quot;-&quot; | wc -l
</code></pre>
<p>查看当前目录下文件数量(<strong>包含</strong>子目录中的文件)：</p>
<pre><code class="language-Shell">ls -lR | grep &quot;-&quot; | wc -l
</code></pre>
<p>查看当前目录内的目录数量(<strong>不包含</strong>子目录中的目录)：</p>
<pre><code class="language-Shell">ls -l | grep &quot;^d&quot; | wc -l
</code></pre>
<p>查看当前目录内的目录数量(<strong>包含</strong>子目录中的目录)：</p>
<pre><code class="language-Shell">ls -lR | grep &quot;^d&quot; | wc -l
</code></pre>
<p>查看以'GUGU'开头的目录下全部文件的数量：</p>
<pre><code class="language-Shell">ls -lR GUGU*/ | grep &quot;-&quot; | wc -l
</code></pre>
<p>其中，<code>ls -l</code>表示以长列表输出指定目录下的信息，<code>grep</code>是一种文本搜索工具，<code>&quot;-&quot;</code>代表文件，<code>&quot;d&quot;</code>代表目录，<code>wc -l</code>表示统计输出信息的行数。</p>
<h3 id="查看进程">查看进程</h3>
<p>我们常使用用ps查看进程，具体方法有如下两种：</p>
<pre><code>ps -ef
</code></pre>
<pre><code>ps -aux
</code></pre>
<p>注意，当进程较多时，我们可以对进程名进行搜索以快速定位：<br>
以进程test.py为例，具体方法有如下两种：</p>
<pre><code>ps -ef | grep test
</code></pre>
<pre><code>pgrep test
</code></pre>
<h3 id="杀死进程">杀死进程</h3>
<p>在查看进程得到进程的编号(PID)后，我们可以使用如下指令杀死进程：</p>
<pre><code>kill -s 9 PID-number
</code></pre>
<p>其中9表示强制结束进程。但有时会报错，可以用如下指令杀死进程：</p>
<pre><code>kill -9 PID-number
</code></pre>
<h3 id="清华源pip">清华源pip</h3>
<p><code>pip install -i https://pypi.tuna.tsinghua.edu.cn/simple some-package</code></p>
<h3 id="pandas读取csv表">pandas读取csv表</h3>
<p>主要要注意的：sep，header，</p>
<p>指定表头的行数 默认为0 可以为其他值 没表头就写header=None 读特定的行<br>
data = pd.read_csv('nn_data_additional.csv', sep=',', header=None, usercols=['a','b'])</p>
<p>指定新表头<br>
csvframe = pd.read_csv(&quot;testcsv_02.csv&quot;,names=['white','red','blue','green','animal'])</p>
<p>读取某一行<br>
print(df.iloc[0])<br>
读取某一列<br>
print(df.iloc[:, 10])<br>
使用行的平均值 补充某列的缺失值</p>
<p>把ave_time这列的缺失值进进行填充，填充的方法是按这一列的平均值进行填充<br>
aveTime=df['ave_time'].mean()<br>
df2=df.fillna(aveTime)<br>
arrs=col.values 获取对应的值</p>
<p>写表<br>
frame = pd.DataFrame([[0,1,2,3],[4,5,6,7],[8,np.NaN,10,11],[12,13,14,15]], columns=['ball', 'pen', 'pencil', 'paper'])<br>
print(frame)<br>
index 写不写左侧的索引 header 写不写表头 nan显示成什么<br>
frame.to_csv(&quot;testcsv_04.csv&quot;, index=False, header=False, na_rep='0')</p>
<p>可以存表成tsv文件，即用\t分隔的，避免了文件中有逗号的情况，但是要注意空格和\t的区别，可以在vscode看出来是点还是箭头，甚至还可以复制其他的tab到特定位置</p>
<h3 id="如何进docker内部调试">如何进docker内部调试</h3>
<p>1 正常起trail，如下更改后docker默认sleep状态，但GPU空闲过久会被杀<br>
SCM：du/envir/conf --- /opt/tiger/envir_conf --- 1.0.0.1<br>
入口：/opt/tiger/envir_conf/entri.sh<br>
2 起trail时调debug模式，会允许GPU闲置很久，但每人只允许开两个debug模式的trail</p>
<h3 id="gitignore无法生效">.gitignore无法生效</h3>
<p>git rm -r --cached .<br>
git add .<br>
git commit -m 'update .gitignore'<br>
其他都博客都是千篇一律的使用了上面的命令<br>
我试了还是不行，然后我把要忽略的文件直接删了，以为这样总可以了吧，竟然还是不行。</p>
<p>我推测应该是，一开始我commit了要忽略的文件，虽然删了文件，但是commit记录里还有原来的文件，然后百度到了删除commit记录的命令。</p>
<p>git reset --mixed 17ef4b4a22c975b4cad7cc4342a7d7a89ba73789<br>
用这行命令回退到 带有忽略文件的commit的上一个commit 然后再重新commit就行了。</p>
<p>git reset --mixed：此为默认方式，不带任何参数的git reset，即时这种方式，它回退到某个版本，只保留源码，回退commit和index信息<br>
git reset --soft：回退到某个版本，只回退了commit的信息，不会恢复到index file一级。如果还要提交，直接commit即可<br>
git reset --hard：彻底回退到某个版本，本地的源码也会变为上一个版本的内容，此命令慎用！</p>
<h3 id="容器安装tmux">容器安装tmux</h3>
<p>sudo chmod 1777 /tmp<br>
sudo apt update<br>
sudo apt install tmux</p>
<h3 id="查看文件行数">查看文件行数</h3>
<p><code>wc -l file</code></p>
<h3 id="mac将pdf转换为裁剪边的eps">Mac将pdf转换为裁剪边的eps</h3>
<p>安装xpdf epstool，使用语句转换<br>
brew install xpdf<br>
brew install epstool<br>
pdftops -eps a.pdf a.eps<br>
epstool --copy --bbox a.eps b.eps</p>
<h3 id="查看文件数量">查看文件数量</h3>
<p>查看当前目录下的文件数量（不包含子目录中的文件）</p>
<p>查看当前目录下的文件数量（包含子目录中的文件）</p>
<pre><code class="language-Shell">ls -lR|grep &quot;^-&quot;| wc -l
</code></pre>
<h3 id="磁盘容量检测">磁盘容量检测</h3>
<p>查看磁盘剩余空间<code>df -hl</code><br>
查看每个根路径的分区大小<code>df -h</code><br>
返回目录大小<code>du -sh FOLDER_NAME</code><br>
返回文件夹内文件数<code>du -sm FOLDER_NAME</code></p>
<h3 id="hadoop">Hadoop</h3>
<p>Hadoop主要是由三部分组成：分布式文件系统HDFS、分布式计算框架MapReduce，还有一个是分布式集群资源调度框架Yarn。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Pytorch杂记]]></title>
        <id>https://FuNian788.github.io/post/pytorch-misc/</id>
        <link href="https://FuNian788.github.io/post/pytorch-misc/">
        </link>
        <updated>2020-09-17T03:20:28.000Z</updated>
        <content type="html"><![CDATA[<p><ul class="markdownIt-TOC">
<li>
<ul>
<li>
<ul>
<li><a href="#torchnnmodule%E4%B8%BB%E8%A6%81%E5%8A%9F%E8%83%BDdshfshfhslfhlkfhs">torch.nn.module主要功能*（*（DSHFSHFHSLFHLKFHS</a></li>
<li><a href="#pytorch%E4%BD%BF%E7%94%A8scatter_%E5%87%BD%E6%95%B0%E5%B0%86label%E5%8F%98%E6%88%90one-hot%E7%BC%96%E7%A0%81">Pytorch使用scatter_函数将label变成one hot编码</a></li>
<li><a href="#dataloader%E4%B8%ADcollate_fn%E7%9A%84%E4%BD%BF%E7%94%A8">DataLoader中collate_fn的使用</a></li>
<li><a href="#nnmodules%E5%92%8Cnnchildren%E7%9A%84%E5%8C%BA%E5%88%AB">nn.modules和nn.children的区别</a></li>
<li><a href="#pytorch%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86">Pytorch内存管理</a></li>
<li><a href="#%E5%B8%B8%E7%94%A8%E5%BC%A0%E9%87%8F%E6%93%8D%E4%BD%9C">常用张量操作</a></li>
<li><a href="#torchtensor%E5%92%8Ctorchtensor%E7%9A%84%E5%8C%BA%E5%88%AB">torch.tensor和torch.Tensor()的区别</a></li>
<li><a href="#modeleval%E6%B6%89%E5%8F%8A%E7%9A%84bn%E5%8F%8Adropout%E5%86%85%E5%AE%B9">model.eval()涉及的BN及Dropout内容</a></li>
<li><a href="#%E5%A4%9Agpu%E7%9A%84%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6">多GPU的处理机制</a></li>
<li><a href="#torchnnparameter">torch.nn.Parameter()</a></li>
<li><a href="#pytorch-conv1d">Pytorch Conv1d</a></li>
<li><a href="#%E9%80%9A%E8%BF%87mask%E5%B0%86%E4%B8%8D%E5%90%8C%E6%A0%B7%E6%9C%AC%E4%BC%A0%E7%BB%99%E4%B8%8D%E5%90%8C%E7%9A%84%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0">通过mask将不同样本传给不同的损失函数</a></li>
<li><a href="#%E4%BC%98%E5%8C%96%E5%99%A8%E7%9B%B8%E5%85%B3">优化器相关</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</p>
<h3 id="torchnnmodule主要功能dshfshfhslfhlkfhs">torch.nn.module主要功能*（*（DSHFSHFHSLFHLKFHS</h3>
<p>nn.Module()是最常用的模块了，与nn.functional只做运算不同，它还会保存权重等信息。</p>
<p>parameters(memo=None): 返回一个 包含模型所有参数 的迭代器。一般用作optimizer参数<br>
children(): 返回当前模型 子模块的迭代器。<br>
name_children(): 返回 包含 模型当前子模块 的迭代器，yield 模块名字和模块本身。<br>
modules(): 返回一个包含 当前模型 所有模块的迭代器。<br>
named_modules(): 返回包含网络中所有模块的迭代器, yielding 模块名和模块本身。</p>
<p>注册功能：</p>
<p>register_parameter(name, param):向module添加 parameter,可以通过name获取<br>
register_forward_hook(hook)：在module上注册一个forward hook。 每次调用<br>
forward()计算输出的时候，这个hook就会被调用。</p>
<p>register_backward_hook(hook)：在module上注册一个bachward hook。每次计算<br>
module的inputs的梯度的时候，这个hook会被调用</p>
<p>register_buffer(name, tensor)：给module添加一个persistent buffer，通常用<br>
来保存一个不需要看成模型参数的状态</p>
<h3 id="pytorch使用scatter_函数将label变成one-hot编码">Pytorch使用scatter_函数将label变成one hot编码</h3>
<p>在制作数据集时，常需要将index标签转换为one hot编码形式，较好的实现方式是通过scatter_函数。<br>
scatter_函数的核心思想是，用给定数据input，基于维度dim和索引index去填充目标矩阵(dim轴上的数值由index确定)：<br>
<code>tensor.scatter_(dim, index, src, reduce=None)</code><br>
举一个最常见的示例：</p>
<pre><code>&gt;&gt;&gt; x = torch.rand(2, 5)
&gt;&gt;&gt; x
 0.4319  0.6500  0.4080  0.8760  0.2355
 0.2609  0.4711  0.8486  0.8573  0.1029
[torch.FloatTensor of size 2x5]
&gt;&gt;&gt; torch.zeros(3, 5).scatter_(0, torch.LongTensor([[0, 1, 2, 0, 0], [2, 0, 0, 1, 2]]), x)
 0.4319  0.4711  0.8486  0.8760  0.2355
 0.0000  0.6500  0.0000  0.8573  0.0000
 0.2609  0.0000  0.4080  0.0000  0.1029
</code></pre>
<p>使用2x5的矩阵去填充3x5的目标矩阵，当dim=0时，使用index填充0维度，则可将index转换成<br>
<code>[[(0,0),(1,1),(2,2),(0,3),(0,4)], [(2,0),(0,1),(0,2),(1,3),(2,4)]]</code>，再将源矩阵中的对应值填充到新矩阵index'的位置。<br>
举例，将N*1的label转换成one hot编码格式，假设N=10，label类别共3类(以1,2,3标记)：</p>
<pre><code class="language-Python">N = 10
label = torch.randint(1, 4, (N, 1))
one_hot_label = (label - 1).long()
one_hot_label = torch.zeros(len(label), N).scatter_(1, one_hot_label, 1)
</code></pre>
<h3 id="dataloader中collate_fn的使用">DataLoader中collate_fn的使用</h3>
<p>Pytorch的DataLoader可选collate_fn参数，从而对每次读取的batch数据进行处理。<br>
当batch选项关闭时，<code>collate_fn</code>函数会在读取每个独立的数据时均被调用，且默认的功能只是将Numpy数组转换成Pytorch tensor；<br>
当batch选项开启时，<code>collate_fn</code>函数会在读取整个batch的数据时被调用，即将独立的数据组合至batch级别，且此过程中默认保留原有数据结构、将Numpy数组转换成Pytorch tensor。举例，设置torch.utils.data.Dataset在__getitem__方法中基于index读取一张图片和一个label，默认的<code>collate_fn</code>会使torch.utils.data.DataLoader返回一个包含batch_size个元组的列表，每个元组内含有一张图片和一个label，类似的列表会由迭代器不断返回，共len(data)/batch_size个(暂不考虑取整)，以代码的形式可视化，返回值为<code>[(image, label) for _ in range(batch_size)]</code>。<br>
有特殊需求时才会改写<code>collate_fn</code>函数，例如在非第一维度外的维度进行concate、对不同长度的序列进行padding等。</p>
<h3 id="nnmodules和nnchildren的区别">nn.modules和nn.children的区别</h3>
<p>nn.children()会返回模型的子元素，可用如<code>list(model.children())</code>方法查看(等价于用<code>model.named_children()</code>迭代器进行遍历)，其中子元素既可能是单独的一层如Linear，也可能是Sequential；<br>
nn.modules()会递归地返回所有的子元素，可用如<code>list(model.modules())</code>方法查看(等价于用<code>model.named_modules()</code>迭代器进行遍历)，其中Sequential内包含的子元素也会被迭代地返回。</p>
<h3 id="pytorch内存管理">Pytorch内存管理</h3>
<p>查看tensor内存状态：<code>tensor.storage()</code><br>
查看tensor间是否共享内存：<code>id(tensor1.storage()) == id(tensor2.storage())</code><br>
查看tensor元首素相对于storage地址的偏移量：<code>tensor.storage_offset()</code><br>
查看tensor内存空间是否连续：<code>tensor.is_contiguous()</code><br>
查看tensor内部的步长信息：<code>tensor.stride()</code><br>
Pytorch中的tensor分为头信息区(tensor)和存储区(storage)，头信息区主要保存tensor的形状、步长、数据类型等信息，真正的数据则以一维连续数组的形式保存在存储区。事实上，绝大多数操作并不修改tensor的实际数据(即存储区的内容)，而是修改tensor的头信息，这样操作既节约内存，处理速度也更快，例如使用索引截取部分tensor后新tensor的内存指向不会发生变化，只会改变对应的地址偏移量，而使用<code>tensor.contiguous()</code>方法会将数据复制到新的内存中，不再共享原有地址。</p>
<h3 id="常用张量操作">常用张量操作</h3>
<p><code>torch.cat(tensors, dim=0, out=None)</code>可对数据在指定维度进行拼接，新数据在该维度上通道数是原数据通道数之和，且此过程要求原数据在非指定维度的其他维度具有相同的shape。</p>
<pre><code class="language-Python">import torch

a = torch.ones(2,3)
b = torch.ones(4,3) * 2
c = torch.ones(1, 3) * 3
print(torch.cat((a, b), 0)) # shape: 7 * 3

c = torch.ones(2, 4, 3)
d = torch.ones(2, 4, 2) * 2
print(torch.cat((c, d), 2)) # shape: 2 * 4 * 5
</code></pre>
<p><code>torch.stack(tensors, dim=0, out=None)</code>是将多个矩阵在新的维度上进行堆叠(会增加新的维度)，一般要求被堆叠矩阵的shape保持相同。其中dim参数的取值范围为0至原有通道数的左闭右闭集合。</p>
<pre><code class="language-Python">import torch

a = torch.ones(2,3)
b = torch.ones(2,3) * 2
c = torch.ones(2,3) * 3
print(torch.stack((a, b, c), dim=2))
</code></pre>
<p><code>torch.transpose(input, dim0, dim1)</code>返回将input维度dim0和dim1调换后的新tensor，能且仅能调换两个维度。该操作仅改变了数据的读取方式，并不改变内存存储，且output与input共享内存。既可以以<code>torch.transpose</code>形式调用，也可以以<code>torch.Tensor.transpose</code>形式调用。</p>
<pre><code class="language-Python">import torch

a = torch.randn(2,3,4)
b = torch.transpose(a, 2, 1)
print(b.shape)  # b.shape: 2 * 4 * 3

b[0, :, :] = 0
print(a, b)     # 'a' will also change its data.
</code></pre>
<p><code>torch.Tensor.permute(*dims)</code>返回将input维度重新排列后的新tensor，必须传入所有维度的索引且能进行多个维度的调换。仅可以以<code>torch.Tensor.permute</code>形式调用。</p>
<pre><code class="language-Python">import torch

a = torch.randn(2, 3, 5)
b = a.permute(2, 0, 1)
print(b, b.shape)   # b.shape: 5 * 2 * 3
</code></pre>
<h3 id="torchtensor和torchtensor的区别">torch.tensor和torch.Tensor()的区别</h3>
<p>torch.tensor()是python函数，会对数据部分做拷贝(而非引用)，根据原始数据类型生成对应torch.LongTensor、torch.FloatTensor和torch.DoubleTensor等。<br>
torch.Tensor()是python类，也是torch.FloatTensor()的简称，使用此会生成FloatTensor。<br>
torch.tensor()内的输入即value，torch.Tensor()内的输入即shape，参考下例：</p>
<pre><code class="language-python">a = torch.tensor(2)     # tensor(2)
b = torch.tensor([2])   # tensor([2])
c = torch.Tensor(2)     # tensor([0., 0.])
d = torch.Tensor([2])   # tensor([2.])
</code></pre>
<p>其实这两者的关系很像numpy中的numpy.array和numpy.ndarray，前者是函数，后者是类对象，可通过前者创建后者。</p>
<h3 id="modeleval涉及的bn及dropout内容">model.eval()涉及的BN及Dropout内容</h3>
<p>如果模型中存在BN(Batch Normalization)和Dropout，需要在训练时添加model.train()，测试时添加model.eval()。<br>
训练时，BN层采用当前batch数据的均值和方差，进行Dropout以更新部网络分参数；<br>
测试时，BN层采用全部训练数据的均值和方差，不进行Dropout，使用所有网络参数。</p>
<h3 id="多gpu的处理机制">多GPU的处理机制</h3>
<p>Pytorch下多GPU的处理机制为：<br>
（1）在各个GPU上初始化模型；<br>
（2）前向传播时，把batch数据分配到各个GPU上进行计算；<br>
（3）将输出结果在主GPU上汇总，计算loss并反向传播，更新主GPU上模型的权值；<br>
（4）将主GPU上的模型复制到其它GPU上。</p>
<h3 id="torchnnparameter">torch.nn.Parameter()</h3>
<p><code>torch.nn.Parameter()</code>可以将一个不可训练的Tensor转换成可训练的Parameter(此时requires_grad默认为True)，并将该Parameter绑定到module中，变成模型参数(<code>model.parameters()</code>)的一部分，从而可以进行参数优化。但注意，Parameter也是tensor，符合一切tensor特性。<br>
<code>torch.tensor(a, requires_grad=True)</code>则不尽相同，其只能将参数变成可训练的，但并未将其绑定到module的Parameters列表中。<br>
具体例程如下所示：</p>
<pre><code class="language-Python">import math
import numpy as np

import torch
import torch.nn as nn
from torch.optim import Adam

class NN_Network(nn.Module):
    def __init__(self,in_dim,hid,out_dim):
        super(NN_Network, self).__init__()
        self.linear1 = nn.Linear(in_dim,hid)
        self.linear2 = nn.Linear(hid,out_dim)
        self.linear1.weight = torch.nn.Parameter(torch.zeros(in_dim,hid))
        self.linear1.bias = torch.nn.Parameter(torch.ones(hid))
        self.linear2.weight = torch.nn.Parameter(torch.zeros(hid,out_dim))
        self.linear2.bias = torch.nn.Parameter(torch.ones(out_dim))
        self.test1 = torch.nn.Parameter(torch.zeros(10))
        self.test2 = torch.tensor([0. for i in range(10)], requires_grad=True)

    def forward(self, input_array):
        h = self.linear1(input_array)
        y_pred = self.linear2(h)
        return y_pred

in_d = 5
hidn = 2
out_d = 3
net = NN_Network(in_d, hidn, out_d)

for param in net.parameters():
    print(type(param.data), param.size())
# print(list(net.parameters()))
# ------------------------------------------
# &lt;class 'torch.Tensor'&gt; torch.Size([10])
# &lt;class 'torch.Tensor'&gt; torch.Size([5, 2])
# &lt;class 'torch.Tensor'&gt; torch.Size([2])
# &lt;class 'torch.Tensor'&gt; torch.Size([2, 3])
# &lt;class 'torch.Tensor'&gt; torch.Size([3])
</code></pre>
<h3 id="pytorch-conv1d">Pytorch Conv1d</h3>
<p>详细文档参考<a href="https://pytorch.org/docs/stable/generated/torch.nn.Conv1d.html?highlight=conv1d#torch.nn.Conv1d">官方文档</a>。<br>
在分析之前先回回顾Conv2d。在Conv2d中，当stride=2，kernel=2时，输入<code>batch_size*C_in*100*100</code>的图片，输出特征大小为<code>batch_size*C_out*50*50</code>，在长宽两个尺度上均有尺度的缩小。<br>
而一维卷积不尽相同，只在特征尺度进行卷积。若输入特征大小为<code>batch_size*C_in*length_in</code>，则输出特征大小为<code>batch_size*C_out*length_out</code>，在此过程中仅对length这单一尺度进行stride、kernel_size和padding等方面的计算。<br>
举例如下：</p>
<pre><code class="language-Python">m = nn.Conv1d(in_channels=16,out_channels=33, kernel_size=3, stride=2)
inputs = torch.randn(20, 16, 50)
outputs = m(inputs)
# outputs.shape: torch.Size([20, 33, 24])
</code></pre>
<h3 id="通过mask将不同样本传给不同的损失函数">通过mask将不同样本传给不同的损失函数</h3>
<p>如果不同样本需要传给不同的损失函数(例如batch内包含正负样本，希望正样本通过loss1和loss2，负样本通过loss2)，不推荐在model的__forward__函数或loss函数中使用if判断样本状态(TF的静态图肯定无法支持，不确定Pytorch的动态图是否支持，就算支持定点反向传播，就算避免了可微上的问题，实际的运算速度也会很慢)，<strong>建议直接使用1-0 mask对样本进行遮盖</strong>，mask可通过数值一致实现零梯度，避免了对应样本的反向传播，也可以蹭上框架中矩阵优化的东风。<br>
加mask方式如下：</p>
<pre><code class="language-Python">output = model(input)
mask = np.ones_like(gt_label)
mask[negative_sample] = 0
# mask.shape == output.shape == gt_label.shape
loss = loss_func(output * mask, gt_label * mask)
</code></pre>
<h3 id="优化器相关">优化器相关</h3>
<p>Pytorch中optim模块的优化器：</p>
<ol>
<li>可使用weight_decay参数设置L2 loss。</li>
<li>可在模型参数位置传入列表以对多个模型的参数进行优化。<br>
<code>optimizer = optim.Adam([model_coarse.parameters(), model_fine.parameters()], lr=opt.learning_rate, weight_decay=opt.weight_decay_l2)</code></li>
</ol>
]]></content>
    </entry>
</feed>